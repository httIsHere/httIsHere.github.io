[
  null,
  {
    "id": "f232c878-e4f8-4496-9d85-9320f7c192d0",
    "slug": "f232c878e4f8449",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060036Z&X-Amz-Expires=3600&X-Amz-Signature=2c48b8d75c61aa2a3de38c09b67a72354f1dc7982a17575d160f22d13d3ef046&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/003-f232c878e4f844969d859320f7c192d0",
    "title": "💟 汪汪周刊 003期：如何突破自己的学习瓶颈",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-13T01:00:00.000Z",
    "published_at": "2023-02-13T01:00:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060036Z&X-Amz-Expires=3600&X-Amz-Signature=2c48b8d75c61aa2a3de38c09b67a72354f1dc7982a17575d160f22d13d3ef046&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/b92fc805-affe-49a2-859c-d44855a2cca3/IMG_6345.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060037Z&X-Amz-Expires=3600&X-Amz-Signature=a1ec21e774c798c00d55961bdb52a7193473a06e7185f82a14bcb475d0650f9f&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 星空葡萄\n\n\n# 前提\n\n\n前几天在逛掘金的时候，看到了一篇大哥写的文章《**如何突破技术瓶颈（适合P6以下**）》，特别有感触，其实毕业后没多久就碰上了疫情导致在工作上一直处于舒适圈也没有突破，一直想学习精进也总是三分热度找不准方向。（在后面会分享该文章部分内容）\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n- 本周比较忙，没有太多的时间去更新和学习，只能尽量保证一周一更。\n- 对了我在FlowUs上开了一个线上自习室，欢迎大家和我一起学习打卡！有兴趣可以填写以下报名表！\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/a75bc9e0-a3f0-436c-99e0-6ff9e525ca97/IMG_6277.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060037Z&X-Amz-Expires=3600&X-Amz-Signature=cfffeb6bbb0d100ca4f436800600601baf5528fbef0ba5fe472cfbd6f5e0d699&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n# 工具\n\n- **ChatGPT 客户端，支持 Mac、Windows、Linux。**[https://github.com/lencx/ChatGPT#-downloads](https://github.com/lencx/ChatGPT#-downloads)\n- **Everything，**在日常工作中由于文件夹越来越多，时常碰到找不到文件夹。Everything是一款Windows系统的文件搜索工具，通过它可以快速查找电脑中的文件以及文件位置，真正实现全盘搜索\n\n# 专业技术领域\n\n- **如何突破技术瓶颈（适合P6以下**）》by 孟祥_成都\n\t- 确立自己的具体发展方向\n\t- 一步步接触比自己能力更高层次的代码\n\t- 输入额外的知识储备\n\t- 工作勇于走出舒适圈\n- • React 计划 signal 功能。\n\n\t> We might add a signals-like primitive to React but I don’t think it’s a great way to write UI code. It’s great for performance. But I prefer React’s model where you pretend the whole thing is recreated every time. Our plan is to use a compiler to achieve comparable performance.\n\n- [**Modularizing React Applications with Established UI Patterns**](https://martinfowler.com/articles/modularizing-react-apps.html)**`英文`****：如何用成熟的 UI 模式把 React 应用模块化。**\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 这周开放组件分享。\n\n# 最后的碎碎念\n\n- 不知不觉已经工作第5个年头了，但是回头看来自己还是一无所获，没有优秀的专业能力，没有学习热情，每天还是在浑浑噩噩，看到别人满满的GitHub commits还是会羡慕，但是自己又很难迈出那一步。\n\n# 话题\n\n\n大家都工作了吗？你们对自己以后的职业发展有规划吗？\n\n\n![](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "06e490bd-5265-4fc2-a756-879420a31442",
    "slug": "06e490bd52654fc",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/027d25c5-d19d-489a-a912-3504f759624a/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060037Z&X-Amz-Expires=3600&X-Amz-Signature=8fd6b47d704ff05448c7375d592b59202841f3876bd04e80d5761e185009b73a&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/002-06e490bd52654fc2a756879420a31442",
    "title": "💟 汪汪周刊 002期：如何保持稳定输出",
    "format": "lake",
    "description": "偷懒",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-06T02:55:00.000Z",
    "published_at": "2023-02-06T02:55:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/027d25c5-d19d-489a-a912-3504f759624a/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060037Z&X-Amz-Expires=3600&X-Amz-Signature=8fd6b47d704ff05448c7375d592b59202841f3876bd04e80d5761e185009b73a&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/0889d968-052a-4039-8def-343395a7beca/41DE8900-07B8-458A-ABE5-FF511EFED51D.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060038Z&X-Amz-Expires=3600&X-Amz-Signature=c34ad9e9b24ac408d9ebc89889140e949165de07f59e31454c17152b95093e78&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 锡兰牛乳茶\n\n\n# 前提\n\n\n我今年的打算是可以有稳定的输入输出，不要再三分热度，但是如何保持稳定的输入输出是一个问题。\n\n\n还有很多人正常输入是没问题的但是不会输入，就像我知识在脑子里但是需要去传达给别人的时候不会组织语言，这都是我今年想要训练自己的方面。\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n- 谷歌将推出ChatGPT竞争对手Bard，Bard是建立在谷歌现有的大型语言模型Lamda的基础上。\n- 技术写作坚持不下去怎么办，可以看张鑫旭大佬的这篇文章[《执行：坚持不下去，怎么办？》](https://juejin.cn/book/7184663814950879270/section/7184824069563351043)，他还有[**技术写作指南**](https://juejin.cn/book/7184663814950879270)这个专栏，等有时间可以购买看一下。\n\n# 工具\n\n- [https://www.galmoe.com/](https://www.galmoe.com/)：提取B站封面的网站，输入视频的bv号就可以下载视频封面\n\n\t![](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/c0f46c85-be26-4bf5-b706-ec286aacf8e7/%E6%88%AA%E5%B1%8F2023-02-09_18.40.45.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060040Z&X-Amz-Expires=3600&X-Amz-Signature=f3d41f274682184223c939732b40a98d9f1ba35b35f94dd48538511e314d2c6d&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n- [https://notion2charts.com/](https://notion2charts.com/)：可以关联Notion数据库制作图表，但是非会员只能创建一个\n\n\t![](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/38705b7d-ae75-4821-866d-15bf86d6c320/notion2charts-hero-image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060041Z&X-Amz-Expires=3600&X-Amz-Signature=712241996b9cf1696a0c7786ee65bb73144ed96025cee127f0bcf34d346a7c1c&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n# 专业技术领域\n\n- `英文`尤雨溪大大的2022年终复盘：[https://blog.vuejs.org/posts/2022-year-in-review.html](https://blog.vuejs.org/posts/2022-year-in-review.html)\n\t- 之前上学和刚毕业的时候接触的技术栈都是Vue，自从换了公司换成React了之后很久没关注过Vue的更新了，之前好像是刚更新Vue3的时候使用了一下，当初可是很热衷于研究Vue源码，后面还得找时间研究研究。\n- `英文`10 Web Development Trends in 2023（2023 年 10 大 Web 发展趋势）：[https://www.robinwieruch.de/web-development-trends/](https://www.robinwieruch.de/web-development-trends/)\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 目前只更新了几个组件，但是还没有正式开放分享，这周尽量完成并公开分享\n- 本周更新一个模版——记账本，下周还会再更新一个——减肥计划模版\n\n# 最后的碎碎念\n\n- 02/06，没想到土耳其一天内发生了2次7.8级的地震，也看到了大唐哥被埋在酒店的新闻，我真的很爱非正式会谈，他的`in my room, on my bed, with my partner`这个梗真的很好笑，有种身边的人发生意外的感觉😭。非正式会谈真的很好看，没有看过的同学可以看一下也是在B站。\n- 终于排到`Notion AI`了，接下去就让它给你讲个故事和回答一下本周的话题吧\n\t- 这是一个关于一只小猪的故事，这只小猪有三个兄弟，他们一起住在一个小屋里，每天都很开心快乐。但是有一天，有一只大灰狼来了，想要吃掉这三只小猪，所以他们三兄弟就开始挖穴，把小猪们藏起来，这就是他们的安全之所。大灰狼看到小猪们挖穴，就渐渐地失去信心，然后就再也没有出现过。最后，小猪们平安无事，每天都很开心快乐。\n\t- 有时候，学习的热情会渐渐减弱，这是很正常的。但是有一些方法可以帮助我们保持下去，比如：\n\t\t- 寻找激励：学习需要有激励，找到自己喜欢的东西，比如一个梦想，一个目标，或者一个崇拜的人物，然后把它作为学习的动力，去向它努力奋斗，这样就可以保持热情。\n\t\t- 找到适合自己的学习方法：每个人都有自己适合的学习方法，要找到自己最适合的学习方法，比如有的人比较适合用看书的方式来学习，有的人比较适合用视频的方式来学习，有的人比较适合用练习的方式来学习，找到自己最适合的学习方法，就可以让学习的热情持续下去。\n\t\t- 分享学习心得：分享学习心得是一个很好的方式，它可以让我们及时发现自己的不足之处，及时补充，也可以让我们更加深入地理解自己学习的内容，有助于提高学习能力，也可以让我们在学习的过程中得到更多的收获，从而提高学习的热情。\n\n\t\t通过以上几点，我们可以保持良好的学习热情，更好地完成学习任务。\n\n- 02/10，凌晨觉得很不安睡不着，每天都在搜索唐大哥的消息，一直刷实时的微博就希望能有好消息，可是没想到等来的却是坏消息，真的很难过，就像身边的朋友离开了一样。\n\n# 话题\n\n\n你平时会通过什么方式保持学习和分享热情？\n\n\n![](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "ef7e5152-eeb5-4d27-9bca-afbf6b972c83",
    "slug": "ef7e5152eeb54d2",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-18-ef7e5152eeb54d279bcaafbf6b972c83",
    "title": "⚫ React Hooks 精进 18 - 服务器端组件",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-12T07:51:00.000Z",
    "created_at": "2023-08-12T07:22:00.000Z",
    "published_at": "2023-08-12T07:22:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# React 17\n\n\n## 渐进升级\n\n\nReact 17带来的渐进升级提供了一种新方案，渐进升级的支持就是一个应用可以同时由多个React版本。\n\n\n## 新的事件模型\n\n\nreact中所有的事件都是合成事件，实现的机制是在根节点上监听所有事件，经过react统一处理后发送到虚拟DOM节点上。\n\n\n在17中，不需要再通过Documnet去监听事件，而是在组件树的根节点上去监听。\n\n\n## 新的JSX编译机制\n\n\n之前要在react组件内使用JSX必须使用import引入react，在编译时JSX会被翻译成`React.createElement`这样的API。\n\n\n而现在才用了新的编译机制，代码内不再需要引入React。\n\n\n## Suspense：悬停渲染\n\n\n> 挂起当前组件的渲染，直到异步操作完成。\n\n\nReact组件是状态驱动的，当状态发生改变，整个组件树都会进行一次整体的刷新，React会将所有的DOM变化一次性渲染道浏览器中，这在应用非常复杂的场景下，会成为一个潜在的性能瓶颈。\n\n\n有了Suspense，异步请求不在需要组件去触发。\n\n\n## Server Components：服务器端React组件\n\n\n能够在组件级别实现服务器端的渲染，在一个前端页面中有些组件是客户端渲染，有些组件是服务器渲染。\n\n"
  },
  {
    "id": "17368c14-3e82-4ed8-aa72-ab854c827a20",
    "slug": "17368c143e824ed",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-17-17368c143e824ed8aa72ab854c827a20",
    "title": "⚫ React Hooks 精进 17 - 单元测试 & 常用的第三方工具库",
    "format": "lake",
    "description": "04-18",
    "updated_at": "2023-08-12T06:24:00.000Z",
    "created_at": "2023-08-12T05:02:00.000Z",
    "published_at": "2023-08-12T05:02:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 单元测试\n\n\n## 使用Jest和React Testing Library进行单元测试\n\n\n### Jest\n\n\nFacebook推出的js但愿测试框架，零配置就能提供并发测试，测试覆盖率，Mock工具，断言API等。\n\n- Jest从哪里寻找测试文件\n- 如何创建一个测试用例，并用断言验证测试结果\n- 如何运行测试\n\n比如在src下有一个add.js的文件：\n\n\n```typescript\nexport default (a, b) => a + b;\n```\n\n\n再在src目录下创建一个`add.test.js`文件，Jest会寻找src目录下以`.test.js(ts, jsx, tsx)`结尾的文件，以及tests文件夹内的文件，并将其作为测试文件。\n\n\n```typescript\n// add.test.js\n\nimport add from './add';\n\n// 使用test函数创建一个测试用例\ntest('renders learn react link', () => {\n\tconst s = add(1, 2)\n\t// Jest提供的expect函数断言结果等于3\n\texpect(s).toBe(3)\n})\n```\n\n\n**创建完测试用例之后可以在项目根目录通过命令****`npx jest —coverage`****来运行测试。**\n\n\n但是这仅仅是纯js的逻辑测试，对于React应用需要浏览器环境的组件需要引入Test Library了。\n\n\n### React Testing Library\n\n1. **需要有一个浏览器运行环境：**主要通过jsdom这样一个npm模块去实现，可以在nodejs环境中提供一个虚拟的浏览器环境。\n2. **需要能够解析JSX**\n3. **需要能够方便地渲染一个React组件，并对结果进行验证**\n\n项目中自带的App.test.js：\n\n\n```typescript\nimport {render, screen } from ‘@testing-library/react’\n\nimport App from './App'\n\ntest('renders learn react link', () => {\n\trender(<App />)\n\n\tconst linkele = screen.getByText(/learn react/i)\n\texpect(linkele).toBeTheDocument();\n})\n```\n\n\n三个React相关的测试API：\n\n- render：用于在内存中render一个React组件\n- screen：提供工具方法用于获取视频上的元素\n- expect扩展：以方便对UI元素进行断言判断\n\n## 对自定义Hooks进行单元测试\n\n\n**Hooks只能在函数组件或者自定义Hooks中调用**，所以要对Hooks进行单元测试，还是需要借助函数组件。\n\n\n```typescript\n// 对计数器useCounter进行测试\n\nimport {render, screen, fireEvent } from ‘@testing-library/react’\n\ntest('useCounter', () => {\n\tconst testComponent = () => {\n\t\tconst { count, increment, decrement } = useCounter();\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<button id=\"btn-dec\" onClick={decrement} />\n\t\t\t\t<span id=\"result\">{count}</span>\n\t\t\t\t<button id=\"btn-inc\" onClick={increment} />\n\t\t\t</>\n\t\t)\n\t}\n\trender(<testComponent />)\n\n\tconst btnDec = document.querySelector('#btn-dec')\n\tconst result = document.querySelector('#result')\n\n\tfireEvent.click(btnDec)\n\texpect(result).toHaveTextContent('-1')\t\n})\n```\n\n\n如何更直接操锁Hooks的API呢，可以将Hook的返回值暴露道函数组件外：\n\n\n```typescript\n// 对计数器useCounter进行测试\n\nimport {render, screen, fireEvent } from ‘@testing-library/react’\n\ntest('useCounter', () => {\n\tconst hookResult = {}\n\tconst testComponent = () => {\n\t\tObjext.assign(hookResult, useCounter());\n\n\t\treturn null\n\t}\n\trender(<testComponent />)\n\n\tact(() => {\n\t\thookResult.increment()\n\t})\n\texpect(hookResult.count).toBe(1)\t\n})\n```\n\n\nTestinfg Library也提供了Hooks测试包：`@testing-library/react-hooks`\n\n\n该测试包提供了renderHook和act等方法，能够更加语义化地去创建自定义Hooks的单元测试。\n\n\n# 常用的第三方工具库\n\n\n## lodash\n\n\n它提供了非常多的工具函数，可以大大提高开发效率。\n\n\n### 使用keyBy将数组快速转换成对象\n\n\n```typescript\nconst data = [\n\t{\n\t\tid: 1,\n\t\tname: \"Ken\",\n\t\tcity: \"Hangzhou\"\n\t},\n\t{\n\t\tid: 2,\n\t\tname: \"Kenny\",\n\t\tcity: \"Guangzhou\"\n\t}\n]\n```\n\n\n```typescript\n// 将其变成一个以name为key的map结构\nimport _ from 'lodash'\nconst byName = _.keyBy(data. 'name')\n```\n\n\n### 使用debounce函数，实现输入防抖\n\n\n可以实现只有在用户停止输入后一个很短的时间内才进行change操作，以保证更好的用户体验。\n\n\n```typescript\n<input onChange={_.dobounce(e => setSearch(e.target.value), 300)} />\n```\n\n\n### 使用template实现简单的模版引擎\n\n\n可以方便地实现一些复杂的字符串生成。\n\n\n可以参考相关的[官方文档](https://www.lodashjs.com/)。\n\n\n## UI库：Ant Design和Material UI\n\n- Material UI：采用了Google的Material Design的设计语言，但是它的**组件库缺少一些高级的功能**。\n- Ant Design：主打企业级应用的场景，提供了各种高级组件，可以满足企业级的复杂交互应用场景。\n\n## react-use\n\n\n### useSearchParams\n\n\n获取URL中的查询字符串。\n\n\n### useEvent\n\n\n如果用DOM的原生API去绑定事件，通常需要在组件创建时去监听，再在销毁时取消监听。useEvent封装了这个逻辑：\n\n\n```typescript\nuseEvent('hashchange', onHashChange)\n```\n\n\n### useCookie\n\n\n它可以方便地去读取，更新或者删除某个Cookie。\n\n\n### usePrevious\n\n\n获取某个state的上一个值。\n\n"
  },
  {
    "id": "d87352fa-777e-4ee6-b467-9529cc8ca26a",
    "slug": "d87352fa777e4ee",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-16-d87352fa777e4ee6b4679529cc8ca26a",
    "title": "⚫ React Hooks 精进 16 - 打包部署",
    "format": "lake",
    "description": "这是之后的学习方向：了解Webpack",
    "updated_at": "2023-08-09T13:46:00.000Z",
    "created_at": "2023-08-09T13:11:00.000Z",
    "published_at": "2023-08-09T13:11:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 了解Webpack\n\n\n通常在实际开发中我们不需要太关注源代码是通过什么编译器如何打包成最后的应用程序的，因为IDE已经帮我们把这些都做好了。\n\n\n但是我们需要知道它的主要功能，以及能够排查问题。\n\n- Failed to compile：编译阶段的错误\n- SyntaxError：语法错误\n\n# Webpack的基本工作原理\n\n\n它的核心思路就是将源代码以及图片，样式文件等资源文件都视为模块，然后通过提供对不同类型资源的处理器，将它们进行统一处理，形成最后可在浏览器运行的代码。\n\n\nWebpack的配置主要分成这几个部分：\n\n- 输入输出配置\n- 配置对于每一类资源的处理器\n- 插件配置\n\n# loader和plugin\n\n\n比如我们想在项目中使用Less作为Css的预处理器，需要在Webpack中进行配置。\n\n- less-loader：将less代码转换成css\n- css-loader：用于处理css中的import，url等语句，分析图片等静态资源\n- style-loader：自动生成代码，并将打包后的css插入页面的style标签。\n\n这个过程设计到loader的一个重要机制：**链式使用**。前面一个loader的输出结果可以作为后一个loader的输入。\n\n\n最终生成的css代码会以字符串的形式作为一个模块打包到最终结果，然后在运行时由style-loader提供一个函数injectStyleIntoStyleTag，将这个模块加入到页面的style标签内。\n\n\n如果希望最终生成的css文件和JavaScript文件分开，此时就需要使用到plugin。\n\n\n只需要简单地引入mini-css-extract-plugin，可以识别所有的CSS模块。\n\n\n所以：\n\n- loader：用于处理不同类型的资源，将它们转换成模块\n- plugin：通常用于生成一些除了js bundle之外的打包结果。\n\n# 思考题\n\n\n代码的混淆和压缩应该用loader还是plugin？\n\n\nloader是针对不同类型文件间的转换、关系处理，最终生成js模块，而plugin是针对某一个文件在打包过程中的处理，所以应该使用plugin。\n\n"
  },
  {
    "id": "e3767b97-b5ac-41c3-a83d-ec0c63889798",
    "slug": "e3767b97b5ac41c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-15-e3767b97b5ac41c3a83dec0c63889798",
    "title": "⚫ React Hooks 精进 15 - 按需加载",
    "format": "lake",
    "description": "这期都是我没怎么了解过的内容",
    "updated_at": "2023-08-09T13:10:00.000Z",
    "created_at": "2023-08-09T12:30:00.000Z",
    "published_at": "2023-08-09T12:30:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n> 控制整个应用的大小，提高加载性能是前端开发需要的挑战。\n\n\n提高首屏加载速度：\n\n- 对应用分包\n- 采用高效的缓存策略\n\n# 实现按需加载\n\n\n## 使用import语句，定义按需加载的起始模块\n\n\n本质在于，需要有动态加载模块的能力——import（ECMA Script标准的一个提案）。\n\n\n这里的import作为一个函数动态运行，会返回一个Promise，在模块加载成功后可以在Promise的then回调函数中去使用这个模块。\n\n\n```typescript\nfunction Page() {\n\tconst [RealPage, setRealPage] = useState(null)\n\timport('./RealPage').then(comp => {\n\t\tsetRealPage(comp);\n\t})\n\tif(!RealPage) return 'Loading...'\n\t\n\treturn <RealPage />\n}\n```\n\n\n**import语句完全由Webpack进行处理的。**Webpack会把./RealPage'这个模块为起点的所有依赖模块单独打成一个包。\n\n\n策略：**按业务模块为目标去做隔离，精良在每个模块的起始页去定义这个拆分点。**\n\n\n## 使用react-loadble实现组件的异步加载\n\n\n```typescript\nimport Loadable from \"react-loadable\";\n\nexport default Loadable({\n  loader: () => import(\"./HelloLazyLoad\"),\n  loading({ error }) {\n    return error ? \"Failed\" : \"Loading\";\n  },\n});\n```\n\n- loader：用于传入一个加载器回调，在组件渲染到页面时被执行\n- loading：用于显示加载状态的组件\n\n# 使用service worker缓存前端资源\n\n\n对于加载性能的优化除了按需加载之外，还有就是前端资源的缓存。合理的缓存策略可以保证同样的前端资源永远只下载一次。\n\n\nservice worker通常用于开发离线的web应用。它还提供了拦截前端请求的能力使得它可以结合localStoage成为一个独立的缓存方案（可以看作一种前端的资源请求代理）。\n\n\nservice worker加上cache storage（存储静态资源在浏览器端）具有更高的准确性和可靠性。\n\n- 缓存永远不过期\n- 永远不会访问过期的资源\n\n## 注册Service Worker\n\n\n```typescript\nif('serviceWorker' in navigator) {\n\tnavigator.serviceWorker.register('sw.js').then(() => {\n\t\tconsole.log('registered.')\n\t})\n}\n```\n\n\n其中sw.js就是Service Worker脚本的代码路径。\n\n\n## 在Service Worker安装后初始化缓存机制\n\n\n在Service Worker的实现代码被下载和执行后，就会触发安装完成的事件，可以在sw.js内监听这个事件，从而初始化自己的缓存机制。\n\n\n```typescript\n// 在sw.js中监听安装完成事件\nself.addeventListener('install', e => {\n\tconst cachePromise = caches.open('app_cache')\ne.waitUntil(cachePromise)\n})\n```\n\n\n**Cache Storage是浏览器提供的一种缓存机制。**\n\n\n## 拦截请求\n\n\n可以通过监听fetch事件来处理所有的请求。\n\n\n```typescript\nself.addeventListener('fetch', e => {})\n```\n\n\n# 思考题\n\n\n除了按需加载和Service Worker，还想到哪些提升应用加载性能的方法？\n\n"
  },
  {
    "id": "f5c52bc4-bd8d-4a13-9221-6c990c713413",
    "slug": "f5c52bc4bd8d4a1",
    "icon": {
      "type": "emoji",
      "emoji": "🆕"
    },
    "cover": null,
    "url": "https://www.notion.so/js-DOM-f5c52bc4bd8d4a1392216c990c713413",
    "title": "🆕 在js内用文本内容定位DOM元素",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-09T12:16:00.000Z",
    "created_at": "2023-08-09T07:47:00.000Z",
    "published_at": "2023-08-09T07:47:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [Javascript]<br />categories: [Daily]<br />cover: null\n\n---\n\n\n> 在开发中遇到了一个需求：在url内输入页面上的按钮label就可以触发按钮的点击事件。\n\n\n\t此时就需要用文本内容来定位页面上的DOM元素。\n\n\n## 1. 遍历法\n\n\n遍历页面上所有的相关元素。\n\n\n```typescript\nArray.from(document.querySelectorAll('span'))\n.find(el => el.textContent.includes('文本内容'))\n```\n\n\n## 2. XPATH表达式\n\n\n```typescript\ndocument.evaluate(\"//span[contains(., '文本内容')]\", document, null, XPathResult.ANY_TYPE).iterateNext();\n```\n\n\n## 3. jQuery\n\n\n```typescript\nvar $span = $(\"span:contains('文本内容')\"); // 获取的是jQuery对象\nvar span = $span.get(0); // 转换为 js 对象\n```\n\n"
  },
  {
    "id": "8f2c2dc3-4623-4e54-af5c-b3d5bf1b8626",
    "slug": "8f2c2dc346234e5",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-14-8f2c2dc346234e54af5cb3d5bf1b8626",
    "title": "⚫ React Hooks 精进 14 - 浮动层的使用 & 路由管理",
    "format": "lake",
    "description": "1， 需要在实战中进行操作尝试。 03-15",
    "updated_at": "2023-08-08T13:22:00.000Z",
    "created_at": "2023-08-08T11:53:00.000Z",
    "published_at": "2023-08-08T11:53:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 浮动层的使用\n\n\n通常的对话框使用：\n\n- 对话框需要在父组件中声明，才能在子组件中控制是否显示。\n- 给对话框传递参数智能由props传入，意味着所有状态管理需要在更高级别的组件上。\n\n## 处理对话框的误区\n\n\n当这里是一个左右分栏布局的页面，在左侧的菜单栏由右侧列表的操作按钮，此时左侧组件和右侧组件共享一个对话框，那么此时就需要在layout这个层级上去设置对话框。\n\n\n但是这种处理方式会有以下两个问题：\n\n- 语义隔离不明确：是两个本不相关的功能产生依赖\n- 难以扩展\n\n需要思考的问题就是：**一个实现业务逻辑的Modal究竟应该在哪个组件中去声明？又该如何进行交互？从而使让对话框相关的业务逻辑能够更加模块化**。\n\n\n## 思路：使用全局状态管理所有对话框\n\n\n对话框本质：独立于其他界面的独立功能。\n\n\n所以我们可以给对话框定义一个全局唯一的ID，通过ID去显示/隐藏对话框并为之传递参数。\n\n\n预期的操作方式：\n\n\n```typescript\nconst modal = useNiceModal(\"user-info-modal\");\nmodal.show(args)\nmodal.hide()\n```\n\n\n## 实现：创建组件和相关API\n\n\n### 首先是全局状态的管理（以Redux为例）\n\n\n创建一个可以处理所有对话框状态的reducer。\n\n\n```typescript\nconst modalReducer = (state = { hiding: {} }, action) => {\n  switch (action.type) {\n    case \"nice-modal/show\":\n      return {\n        ...state,\n        [action.payload.modalId]: action.payload.args || true,\n        hiding: {\n          ...state.hiding,\n          [action.payload.modalId]: false,\n        },\n      };\n    case \"nice-modal/hide\":\n      return action.payload.force\n        ? {\n            ...state,\n            [action.payload.modalId]: false,\n            hiding: { [action.payload.modalId]: false },\n          }\n        : { ...state, hiding: { [action.payload.modalId]: true } };\n    default:\n      return state;\n  }\n};\n```\n\n\n```typescript\n// action creators\nfunction showModal(modalId, args) {\n  return {\n    type: \"nice-modal/show\",\n    payload: {\n      modalId,\n      args,\n    },\n  };\n}\n\nfunction hideModal(modalId, force) {\n  return {\n    type: \"nice-modal/hide\",\n    payload: {\n      modalId,\n      force,\n    },\n  };\n}\n```\n\n\n创建一个Hook，保证逻辑重用：\n\n\n```typescript\nconst modalCallbacks = {};\nconst useNiceModal = (modalId) => {\n  const dispatch = useDispatch();\n  const show = useCallback(\n    (args) => {\n      return new Promise((resolve) => {\n        modalCallbacks[modalId] = resolve;\n        dispatch(showModal(modalId, args));\n      });\n    },\n    [dispatch, modalId],\n  );\n  const resolve = useCallback(\n    (args) => {\n      if (modalCallbacks[modalId]) {\n        modalCallbacks[modalId](args);\n        delete modalCallbacks[modalId];\n      }\n    },\n    [modalId],\n  );\n\n  const hide = useCallback(\n    (force) => {\n      dispatch(hideModal(modalId, force));\n      delete modalCallbacks[modalId];\n    },\n    [dispatch, modalId],\n  );\n\n  const args = useSelector((s) => s[modalId]);\n  const hiding = useSelector((s) => s.hiding[modalId]);\n\n  return useMemo(\n    () => ({ args, hiding, visible: !!args, show, hide, resolve }),\n    [args, hide, show, resolve, hiding],\n  );\n};\n\n// 封装一个通用对话框\nfunction NiceModal({ id, children, ...rest }) {\n  const modal = useNiceModal(id);\n  return (\n    <Modal\n      onCancel={() => modal.hide()}\n      onOk={() => modal.hide()}\n      afterClose={() => modal.hide(true)}\n      visible={!modal.hiding}\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n}\n```\n\n\n最后可以使用容器模式，在对话框关闭时直接返回null从而以保证性能。\n\n\n```typescript\nexport const createNiceModal = (modalId, Comp) => {\n  return (props) => {\n    const { visible, args } = useNiceModal(modalId);\n    if (!visible) return null;\n    return <Comp {...args} {...props} />;\n  };\n};\n```\n\n\n最后就是调用操作：\n\n\n```typescript\nimport { Button } from \"antd\";\nimport { createStore } from \"redux\";\nimport { Provider } from \"react-redux\";\nimport NiceModal, {\n  createNiceModal,\n  useNiceModal,\n  modalReducer,\n} from \"./NiceModal\";\n\n// redux store\nconst store = createStore(modalReducer);\n\nconst MyModal = createNiceModal(\"my-modal\", () => {\n  return (\n    <NiceModal id=\"my-modal\" title=\"Nice Modal\">\n      Hello NiceModal!\n    </NiceModal>\n  );\n});\n\nfunction MyModalExample() {\n  const modal = useNiceModal(\"my-modal\");\n  return (\n    <>\n      <Button type=\"primary\" onClick={() => modal.show()}>\n        Show Modal\n      </Button>\n      <MyModal />\n    </>\n  );\n}\nexport default () => {\n  return (\n    <Provider store={store}>\n      <h1>Nice Modal</h1>\n      <MyModalExample />\n    </Provider>\n  );\n};\n```\n\n\n### 处理对话框的返回值\n\n- 对话框可能需要返回值给调用者\n\n所以可以利用Promise来完成：\n\n\n```typescript\nconst modal = useNiceModal(\"my-modal\");\nmodal.show(args).then(res => {})\n\n// 在useNiceModal内\nconst show = useCallback(\n    (args) => {\n      return new Promise((resolve) => {\n        modalCallbacks[modalId] = resolve;\n        dispatch(showModal(modalId, args));\n      });\n    },\n    [dispatch, modalId],\n  );\n  const resolve = useCallback(\n    (args) => {\n      if (modalCallbacks[modalId]) {\n        modalCallbacks[modalId](args);\n        delete modalCallbacks[modalId];\n      }\n    },\n    [modalId],\n  );\n```\n\n\n## 思考题\n\n\n如果是基于Context该如何实现NiceModal？\n\n\n# 路由管理\n\n- 路由提供了按页面去组织整个应用程序的能力\n- URL（Uniform Resource Locator），表明URL是用于唯一的定位某个资源的\n\n## 路由的工作原理：实现一个简单的路由机制\n\n\n所谓的页面切换就是一个页面局部内容的组件切换。\n\n- 在服务器渲染的页面，URL的变化都是全部页面内容的切换\n- 前段路由管理中，则一般只是主内容区域的变化\n\n实现路由机制的核心逻辑**：根据URL路径这个状态来决定内容区域显示什么组件**。\n\n\n```typescript\nconst MyRouter = ({ children }) => {\n  const routes = _.keyBy(\n    children.map((c) => c.props),\n    \"path\",\n  );\n  const [hash] = useHash();\n  const Page = routes[hash.replace(\"#\", \"\")]?.component;\n  return Page ? <Page /> : \"Not found.\";\n};\n\nconst Route = () => null;\n```\n\n\n其中空组件Route可以接收路由的具体参数path和component从而以声明式的方式去定义路由。\n\n\n```typescript\n<MyRouter>\n            <Route path=\"page1\" component={Page1} />\n            <Route path=\"page2\" component={Page2} />\n            <Route path=\"page3\" component={Page3} />\n            <Route path=\"page4\" component={Page4} />\n</MyRouter>\n```\n\n\n## 使用React Router\n\n\n实际项目中需要考虑：路由嵌套，URL模式匹配，参数提取等。\n\n\nReact Router不仅支持浏览器还支持React Native以及一些用Web实现的移动App。\n\n\n通常在开发中使用的react-router-dom是支持浏览器的模块。\n\n\n### BrowserRouter\n\n\n表示用标准的URL路径去管理路由。\n\n\n### Link\n\n\n定义一个导航链接，可以无刷新地改变页面URL。\n\n\n### Route\n\n\n定义一条路由规则，可以指定匹配路径和渲染内容。\n\n\n### Switch\n\n\n可以保证只有第一个匹配到的路由才会被渲染。\n\n\n## 使用嵌套路由：实现二级导航\n\n- 能够模糊匹配\n- Route能够嵌套使用\n\n## 在URL中保存页面状态\n\n\n利用React Router的参数功能来定义一条路由。\n\n\n```typescript\n<Route path=\"/tabs/:activeTab\" component={TabsPage} />}\n```\n\n\n## 路由层面实现权限控制\n\n\n利用前端路由的动态性。\n\n\n```typescript\nimport { useState } from \"react\";\nimport { Button } from \"antd\";\nimport { Route, Link } from \"react-router-dom\";\n\nconst Page1 = () => \"Page 1\";\nconst Page2 = () => \"Page 2\";\nconst UnauthedPage = () => (\n  <span style={{ color: \"red\" }}>Unauthorized, please log in first.</span>\n);\nexport default () => {\n  const [loggedIn, setLoggedIn] = useState(false);\n  const routes = loggedIn\n    ? [\n        {\n          path: \"/15/RouterAuth\",\n          component: Page1,\n        },\n        {\n          path: \"/15/RouterAuth/page1\",\n          component: Page1,\n        },\n        {\n          path: \"/15/RouterAuth/page2\",\n          component: Page2,\n        },\n      ]\n    : [{ path: \"/15/RouterAuth\", component: UnauthedPage }];\n\n  return (\n    <div>\n      <h1>Router Auth</h1>\n      <Button\n        type={loggedIn ? \"primary\" : \"\"}\n        onClick={() => setLoggedIn((v) => !v)}\n      >\n        {loggedIn ? \"Log Out\" : \"Log In\"}\n      </Button>\n\n      <div className=\"exp-15-router-auth\">\n        <div className=\"exp-15-sider\">\n          <Link to=\"/15/RouterAuth/page1\">Page 1</Link>\n          <Link to=\"/15/RouterAuth/page2\">Page 2</Link>\n        </div>\n        <div className=\"exp-15-page-container\">\n          {routes.map((r) => (\n            <Route path={r.path} component={r.component} />\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n```\n\n\n## 思考题\n\n\n为什么URL存储状态可以简化页面之间的交互？\n\n\n因为如果子页面需要来自父页面的参数时，通过URL可以更好地定位。\n\n"
  },
  {
    "id": "cd925242-43e3-4316-ad82-87c753f6ce2b",
    "slug": "cd92524243e3431",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-13-Hooks-Form-cd92524243e34316ad8287c753f6ce2b",
    "title": "⚫ React Hooks 精进 13 - Hooks给Form带来的新变化",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-06T07:51:00.000Z",
    "created_at": "2023-08-06T07:20:00.000Z",
    "published_at": "2023-08-06T07:20:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 在表单中使用React组件：受控组件和非受控组件\n\n\n非受控组件：表单元素的值不是由副组件决定的，是完全内部的状态\n\n\n通过非受控组件的方式，可以避免某些程度上的组件重复渲染导致的性能问题，但是无法对外有交互。\n\n\n# 使用Hooks简化表单处理\n\n\n维护表单组件的状态逻辑，核心在于：**字段名，value值，onChange事件**。\n\n\n这就是很多组件库里的useForm这个功能，可以通过提供字段名去取值和设值，就不需要繁琐地为每个表单元素设置状态。\n\n\n核心原理：**把表单的状态管理单独提取出来**， 成为一个可重用的Hook。\n\n\n## 处理表单验证\n\n- 如何定义错误状态\n- 如何设置错误状态\n\n可以传递validators对象给useForm这个Hook，然后在hook内在setFieldValue时对其进行验证，并在返回时返回错误信息给调用者。\n\n\n**关键就是在于把表单状态逻辑和UI展示逻辑给予Hooks进行分离。**\n\n\n```typescript\nimport { useState, useMemo, useCallback } from \"react\";\n\nconst useForm = (initialValues = {}, validators) => {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n\n  const setFieldValue = useCallback(\n    (name, value) => {\n      setValues((values) => ({\n        ...values,\n        [name]: value,\n      }));\n\n      if (validators[name]) {\n        const errMsg = validators[name](value);\n        setErrors((errors) => ({\n          ...errors,\n          [name]: errMsg || null,\n        }));\n      }\n    },\n    [validators],\n  );\n\n  return { values, errors, setFieldValue };\n};\n\nexport default () => {\n  const validators = useMemo(() => {\n    return {\n      name: (value) => {\n        if (value.length < 2) return \"Name length should be no less than 2.\";\n        return null;\n      },\n      email: (value) => {\n        if (!value.includes(\"@\")) return \"Invalid email address\";\n        return null;\n      },\n    };\n  }, []);\n  const { values, errors, setFieldValue } = useForm({}, validators);\n  const handleSubmit = useCallback(\n    (evt) => {\n      evt.preventDefault();\n      console.log(values);\n    },\n    [values],\n  );\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Name: </label>\n        <input\n          value={values.name || null}\n          onChange={(evt) => setFieldValue(\"name\", evt.target.value)}\n        />\n        {errors.name && <span style={{ color: \"red\" }}>{errors.name}</span>}\n      </div>\n\n      <div>\n        <label>Email:</label>\n        <input\n          value={values.email || null}\n          onChange={(evt) => setFieldValue(\"email\", evt.target.value)}\n        />\n        {errors.email && <span style={{ color: \"red\" }}>{errors.email}</span>}\n      </div>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n\n# 思考题\n\n1. 如何在自定义的useForm Hook中提供reset的API？\n\n\t就是返回一个置空的函数。\n\n2. 在自定义的useForm内如何实现支持异步验证？\n"
  },
  {
    "id": "77392cbf-81de-473c-908a-44554fc2298c",
    "slug": "77392cbf81de473",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-12-77392cbf81de473c908a44554fc2298c",
    "title": "⚫ React Hooks 精进 12 - 项目结构：按领域组织文件夹结构",
    "format": "lake",
    "description": "还需要再思考一下，是一个实际开发思维的转变。",
    "updated_at": "2023-08-06T07:51:00.000Z",
    "created_at": "2023-08-06T06:38:00.000Z",
    "published_at": "2023-08-06T06:38:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n**在实际开发中，关键在于：每增加一个新的功能，整个应用程序的复杂度不应该明显上升，这样才能保证应用程序始终可扩展，可维护。**\n\n\n# 软件复杂度的根源：复杂的依赖关系\n\n\n## 按领域组织文件夹结构\n\n\n通常在开发中会从技术角度对文件夹进行拆分，而不是按照业务功能组织在一起，这样会导致无法直观的知道一个功能的相关代码在哪些文件夹，还有开发一个功能时需要频繁切换源代码目录。\n\n\n我们可以从领域角度出发组织源代码，自身就包含需要的所有技术模块。\n\n\n并且需要尽量扁平化地组织所有代码，而不要按小功能去增加嵌套的文件夹。\n\n\n## 处理模块间的依赖：模块间的交互\n\n\n**把依赖从技术层面提升到业务层面。**\n\n- 硬依赖：功能A地实现必须基于功能B\n- 软依赖：功能B扩展了功能A\n\n开发需要达到的目标是：**删除一个功能像删除一个文件夹那么简单**，这才是真正的松耦合的系统。\n\n\n所以需要做的就是让模块之间的交互不在通过硬依赖。\n\n\n### 扩展点机制：在任何可能产生单点复杂度的模块中，通过扩展点的方式允许其他模块为其增加功能。\n\n\n[http://github.com/rekit/js-plugin](http://github.com/rekit/js-plugin)\n\n\n利用类似事件的订阅和发布模型去建立这样一个机制。\n\n\n# 思考题\n\n\n如果使用了Redux，如何在采用按领域组织时让业务功能的Redux在各自的文件夹下呢？\n\n"
  },
  {
    "id": "f92c3fda-f36c-4ac7-a7b6-6ef18822baf7",
    "slug": "f92c3fdaf36c4ac",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-11-f92c3fdaf36c4ac7a7b66ef18822baf7",
    "title": "⚫ React Hooks 精进 11 - 创建自定义事件",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-06T07:19:00.000Z",
    "created_at": "2023-08-05T08:10:00.000Z",
    "published_at": "2023-08-05T08:10:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\nprops是组件之间通信的基础。\n\n\n# 在React中使用原生事件\n\n\n## React原生事件的原理：合成事件\n\n\n由于虚拟DOM的存在，在React中即使绑定一个事件到原生的DOM节点，事件也并不是绑定在对应的节点上，而是**所有的事件都是绑定在根节点上**，然后由React统一监听和管理，获取事件后分发到具体的虚拟DOM节点上。（浏览器事件的冒泡模型，无论事件是在哪个节点被触发，React都可以通过事件的srcElement这个属性知道他从哪个节点发出的）。\n\n\n## 创建自定义事件\n\n\n对于自定义组件，组件内的自定义事件也是非常重要的一部分，虽然自定义事件和原生事件看上去相似，但机制完全不一样：\n\n- 原生事件是浏览器的机制\n- 自定义事件则是纯粹的组件自己的行为，本质是一种**回调函数机制**\n\n习惯上会将这样的回调函数命名为**onSomething**。\n\n\n## 使用Hooks封装键盘事件\n\n\n比如在一个表格页面支持左右键进行翻页的功能，那么需要我们在useEffect内做window。addEvent Listener，然后在返回回调函数内remove。\n\n\n如果使用Hook来实现，就可以在多个组件中使用了。\n\n\n```typescript\nconst useKeyPress = (domeNode = document.body) => {\n\tconst [key, setKey] = useState(null);\n\tuseEffect(() => {\n\t\tdomNode.addEventListener('keypress', handleKeyPress)\n\t\treturn () => {\n\t\t\tdomNode.removeEventListener('keypress', handleKeyPress)\n\t\t}\n\t}, [domNode)\n}\n```\n\n\n# 思考题\n\n\n如何用Hook实现监听两个按键同时按下？\n\n\n同时按下两个按钮会触发两个keyPress事件，可以通过数组存储key，在keyup的时候清空数组。\n\n"
  },
  {
    "id": "d51b7809-92d6-4506-84e0-c7ec9ae37b7a",
    "slug": "d51b780992d6450",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-10-d51b780992d6450684e0c7ec9ae37b7a",
    "title": "⚫ React Hooks 精进 10 - 函数组件设计模式",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-08-05T06:53:00.000Z",
    "published_at": "2023-08-05T06:53:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 函数组件设计模式\n\n\n保证状态的唯一数据源，语义化的拆分复杂组件都是一些设计模式。\n\n\n## 容器模式：实现按条件执行Hooks\n\n\n注意点：**Hooks必须在顶层作用域调用（因为React需要在函数组件内部维护所用到的Hooks的状态）**。\n\n\n比如有一个对话框组件，我们只想要它在组件出现时执行业务逻辑，那么就可以在Hook内部判断如果不显示则返回null。\n\n\n```typescript\nfunction UserModal(visible) {\n\tif(!visible) return null;\n\t\n\tuseEffect(......)\n\n\treturn <div>...</div>\n}\n```\n\n\n但是显然这样是无法通过编译的，因为在return之后使用了useEffect这个Hook。\n\n\n所以这里需要用到一个**容器模式**，就是**把条件贩毒案的结果放在两个组件之中，确保真正的render UI的组件收到的所有属性都是有值的**。\n\n\n```typescript\nfunction UserModalWrapper(visible) {\n\tif(!visible) return null;\n\n\treturn <UserModal visible />\n}\n```\n\n\n就是在原来的函数组件外增加一个容器，这样就可以实现对应的条件渲染。\n\n\n这样的好处是可以在根组件下减少条件判断语句，可以确保每个组件尽量短小，更便于阅读和维护。\n\n\n也可以将一些非render UI相关的逻辑自包含进hooks内。\n\n\n## 使用render props模式重用UI逻辑\n\n\n**把一个render函数作为属性传递给某个组件，由这个组件去执行这个函数从而render实际的内容。**\n\n\n在函数组件内hooks只能用作数据逻辑的重用，而涉及到UI就有些麻烦，这时候就可以尝试render props这个设计模式。\n\n\n使用render props如何封装一个计数器，让他可以在不同的组件内使用。\n\n\n```typescript\nfunction CounterRenderProps({ children }) {\n\tconst [count, setCount] = useState(0);\n\tconst change = useCallback((step = 1) => {\n\t\tsetCount( count + step);\n\t}, [count])\n\t\n\treturn children({count, change})\n}\n```\n\n\n```typescript\n// 调用时\nfunction Counter() {\n\treturn <CounterRenderProps>\n\t\t{({count, change}) => {\n\t\t\treturn <div>....</div>\n\t\t}}\n\t</CounterRenderProps>\n}\n```\n\n\n这里就是利用了children的这个特殊属性，也就是组件开始tag和结束tag之间的内容其实都会作为children这个属性传递给组件的。\n\n\n很显然使用Hooks的方式是更简洁的，但是还是**需要掌握Render props这种设计模式**。\n\n\n**这里需要研究老师给出的这个ListWithMore的例子。**\n\n"
  },
  {
    "id": "86b2af18-6c26-415b-a00c-1efc46ecb9ff",
    "slug": "86b2af186c26415",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/Chapter-1-86b2af186c26415ba00c1efc46ecb9ff",
    "title": "⚫ Chapter 1",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-06T08:33:00.000Z",
    "created_at": "2023-07-27T14:59:00.000Z",
    "published_at": "2023-07-27T14:59:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [日语]<br />categories: [日语初级]<br />cover: null\n\n---\n\n"
  },
  {
    "id": "fc979d69-7f5d-45c3-b8a2-883601a91989",
    "slug": "fc979d697f5d45c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-9-fc979d697f5d45c3b8a2883601a91989",
    "title": "⚫ React Hooks 精进 9 - 异步处理：向服务端发送请求",
    "format": "lake",
    "description": "03-09",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-15T13:47:00.000Z",
    "published_at": "2023-07-15T13:47:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 实现自己的API Client\n\n\n在项目内实现异步请求时第一个事情就是创建自己的API Client，之后所有的请求都可以通过这个Client发出去。\n\n- 一些通用的header\n- 服务器地址的配置：比如可以根据当前环境判断连接的服务器地址\n- 请求未认证的处理\n\n# 使用Hooks思考异步请求：封装远程资源\n\n\n对于一个get类型的API，可以将它看成一个远程的数据源：\n\n- Data\n- Error\n- Pending\n\n比起将请求直接写在组件内部，迁移到一个Hook内可以把组件的表现层逻辑写得更加简洁，将API的调用看作一个数据获取。\n\n\n之后只需要将获取到的数据映射到JSX并显示出来即可。\n\n\n这个模式**仅适用于get请求逻辑**，对于其他类型可查看第六节的useAsync。\n\n\n# 多个API调用：处理并发或者串行请求\n\n\n比如一个博客文章展示页面的场景，这里需要三个请求：\n\n- 文章详情\n- 作者信息，包括名字，头像等\n- 文章的评论\n\n此时包含了并发和串行的场景，文章详情和评论可以并发请求，作者的信息需要等文章内容返回才能知道作者ID，这是串行场景。\n\n\n```typescript\n// 传统场景\nconst [article, comments] = await Promise.all([\n\tfetchArticle(id)\n\tfetchComments(id)\n])\nconst user = await fetchUser(article.user_id)\n```\n\n\nReact函数组件是一个同步函数，没有办法直接使用await这样的同步方法，而是需要将请求通过副作用去触发。\n\n\n此时需要回到React的本质——状态驱动UI。\n\n\n**可以从状态变化的角度去组织异步调用，通过不同的状态组合来实现异步请求的逻辑。**\n\n\n此时的实现思路：\n\n- 组件首次渲染，需要两个副作用去获取文章和评论\n- 组件首次渲染，作者ID不存在不发送任何请求\n- 文章内容返回，开始发送请求作者信息\n- 展示作者信息\n\n```typescript\nconst {data: article, loading, error} = useArticle(id)\nconst {data: comments} = useComments(id)\nconst {data: user} = useUser(article?.user_id)\n// 在useUser内增加一个user_id的依赖项和判断\n```\n\n\n# 思考\n\n1. 每次调用useArticle这个Hook就会触发副作用去获取数据，但是有时候需要组件自动获取，有些需要点击某个按钮才去获取，此时如何去设计这个Hook？\n\n\t我的回答：增加一个是否请求的deps？\n\n2. Hook都是使用useState保存了状态数据，意味着状态的范围限定在组件内部，组件销毁后数据就没了，此时希望数据直接缓存到全部状态该如何做？\n\n\t我的回答：使用redux或者localStorage？\n\n"
  },
  {
    "id": "d45a2962-7dc2-44c4-b766-ad01ece3024b",
    "slug": "d45a29627dc244c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-8-d45a29627dc244c4b766ad01ece3024b",
    "title": "⚫ React Hooks 精进 8 - 复杂状态处理",
    "format": "lake",
    "description": "03-08",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-15T13:13:00.000Z",
    "published_at": "2023-07-15T13:13:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 状态一致性\n\n\n**React开发就是复杂应用程序状态的管理和开发。**\n\n\n# 原则一：保证状态最小化\n\n\n在保证State完整性的同时也要保证它的最小化，如果某些数据能从已有的state中计算得到那么不要把计算的结果存到state内。\n\n\n按照React的状态驱动UI的思想，开发时第一步要**考虑整个功能有哪几个状态**。\n\n\nReact提供的`useMemo`这个Hook就可以缓存计算的结果。\n\n\n# 原则二：避免中间状态，确保唯一数据源\n\n\n在有些场景下，比如原始状态数据来自某个外部数据源，非state或者props，冗余状态就没有那么明显，此时需要准确定位状态的数据源并在开发中确保它是唯一的数据源。\n\n\n**这里的例子是URL上查询关键词同步的场景。**\n\n\n# 实战演练：创建自定义受控组件\n\n\n## 受控组件：组件的展示完全由传入的属性决定。\n\n\n## 非受控组件：表单组件可以有自己的内部状态且他的展示值不受控。\n\n\n## 自定义受控组件：\n\n- 避免多余的状态：不需要在自定义组件内部去定义状态用于保存数据\n- 找到准确的唯一数据源：准确且唯一的来源就是福组件传递进来的状态\n\n# 思考\n\n\n如何实现useSearchParams（用于监听查询参数的变化）这个Hook？\n\n\nhistory.pushState不会出发页面重新渲染，所以通常只能获取第一次的URL参数，如果URL参数发生变化无法查询到，所以可以通过patch的方法来监听url变化。\n\n"
  },
  {
    "id": "29fcc859-25db-44ce-a8b3-8cc4120c4b0f",
    "slug": "29fcc85925db44c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-7-Redux-29fcc85925db44cea8b38cc4120c4b0f",
    "title": "⚫ React Hooks 精进 7 - 全局状态管理 Redux",
    "format": "lake",
    "description": "02-07",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-15T06:49:00.000Z",
    "published_at": "2023-07-15T06:49:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n**Redux是状态管理框架，基于不可变数据的机制。**\n\n\n# Redux的出现背景\n\n\n原先的数据传递：组件级别的state，从上而下的props两个状态机制。\n\n\n但是无法满足类似跨层级的组件数据共享和传递。\n\n\n## Redux Store的特点\n\n- **Redux Store是全局唯一的。**\n- **Redux Store是树状结构。**\n\n## 使用场景\n\n- 跨组件的状态共享\n- 同组件多个实例的状态共享\n\n# 基本概念\n\n- State：即Store\n- Action：用于描述发生的动作\n- Reducer：接受Action和State作为参数通过计算得到新的Store\n\n## 好处：\n\n- 保证数据的不可变性：**在Reducer内每次必须返回一个新的对象**\n- 可预测性\n- 易于调试：可以跟踪Store中数据的变化\n\n## Redux逻辑步骤\n\n- 创建store\n- 利用Action和Reducer修改Store\n- 利用subscribe监听store变化\n\n```typescript\nimport { createStore } from \"redux\";\n\nconst initStore = { value: 0 };\n\nfunction counterReducer(state = initStore, action) {\n  switch (action.type) {\n    case \"counter/incremented\":\n      return { value: state.value + 1 };\n    case \"counter/decremented\":\n      return { value: state.value - 1 };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(counterReducer)\nstore.subscribe(() => console.log(store.getState()));\n\nconst incrementAction = { type: \"counter/incremented\"}\nconst decrementAction = { type: \"counter/decremented\"}\n\nstore.dispatch(incrementAction)\nstore.dispatch(incrementAction)\nstore.dispatch(decrementAction)\n```\n\n\n# 使用方法\n\n- React组件能在依赖的Store的数据发生变化时重新render\n- 在React组件中，能够在某些时机去dispatch一个action，从而出发store的更新\n\n**需要在React内引入react-redux工具库，让React和Redux实现互通。**\n\n\n为了确保需要绑定的组件能够访问到全局唯一的Redux Store，需要利用React的Context机制去存放Store信息。\n\n\n```typescript\nimport { Provider } from 'react-redux'\n\nReactDOM.render(\n\t<Provider store={store}>\n\t\t<App />\n\t</Provider>,\n\trootElement\n)\n```\n\n\n**然后就可以利用react-redux提供的****`useSelector`****和****`useDispatch`****两个Hooks来使用Redux了。**\n\n- `useSelector`：让组件在Store的某些数据发生变化时重新render\n\n```mermaid\ngraph TD\n  Reducer --> Store\n\tStore --> View\n\tView --> Action\n\tAction --> Reducer\n```\n\n\n# 利用Redux处理异步逻辑（异步Action）\n\n\n在Store内我们不仅维护着业务数据同时维护着应用程序的状态。\n\n\nstore的主要变化：\n\n- 请求发送时：设置`state.pending = true` → 用于UI显示加载中状态\n- 请求发送成功：设置`state.pending = false, state.data = result` → 取消加载状态同时将获取的数据展示在UI上\n- 请求发送失败：设置`state.pending = false, state.error = error` → 取消加载状态，设置错误状态和信息，用于在UI上显示错误内容\n\n```typescript\nfunction DataList() {\n    const dispatch = useDispatch();\n    useEffect(() => {\n        dispatch({type: 'FETCH_START'})\n        fetch('/xxx').then(res => {\n            dispatch({type: 'FETCH_SUCCESS', data: res})\n        }).catch(err => {\n            dispatch({type: 'FETCH_ERROR', error: err})\n        })\n    }, [])\n    const data = useSelector(state => state.data)\n    const pending = useSelector(state => pending)\n    const error = useSelector(state => error)\n    if(error) return 'Error'\n    if(pending) return 'Loading...'\n    return <Table data={data} />\n}\n```\n\n\n在上述代码中使用三个同步Action完成这个异步请求的场景，这里将store完全作为一个存放数据的地方。\n\n\n发送请求获取数据并进行错误处理的逻辑是不可重用的，如果在另一个组件中也使用同样的请求就需要在组件内重新实现一遍。\n\n\n因此Redux提供了**middleware**机制可以巧妙地实现异步Action的概念。\n\n\nmiddleware可以让你提供一个拦截器在reducer处理action之前被调用，在拦截器内可以自由地处理获得的action。\n\n\n**Action → Middleware → Reducer**\n\n\n然后Redux提供了react-thunk的中间件，它如果发现接收到的action是一个函数，那么就不会传递给reducer而是执行这个函数，并把dispatch作为参数传给这个函数。\n\n\n```typescript\nimport {createStore, applyMiddleware} from 'react'\nimport thunkMiddleware from 'redux-thunk'\nimport rootReducer from './reducer'\n\nconst composedEnhancer = applyMiddleware(thunkMiddleware)\nconst store = createStore(rootReducer, composeEnhancer)\n```\n\n\n```typescript\nfunction fetchData() {\n    return dispatch => {\n        dispatch({type: 'FETCH_START'})\n        fetch('/xxx').then(res => {\n            dispatch({type: 'FETCH_SUCCESS', data: res})\n        }).catch(err => {\n            dispatch({type: 'FETCH_ERROR', error: err})\n        })\n    }\n}\n```\n\n\n```javascript\nfunction DataList2() {\n    const dispatch = useDispatch()\n    dispatch(fetchData())\n}\n```\n\n\n**通过这种方式就可以实现异步请求的重用，这一套结合redux-thunk中间件的机制称之为异步Action（更像是Redux的使用模式，通过组合使用同步Action用一致的方式提供处理异步逻辑的方案）。**\n\n\n# 思考题\n\n\n只考虑Redux，如何在计数器内实现指定的变量值。\n\n"
  },
  {
    "id": "3666e4e0-a1f0-4db5-a818-76ac2e87c481",
    "slug": "3666e4e0a1f04db",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-6-3666e4e0a1f04db5a81876ac2e87c481",
    "title": "⚫ React Hooks 精进 6 - 典型的使用场景",
    "format": "lake",
    "description": "02-06",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-10T14:45:00.000Z",
    "published_at": "2023-07-10T14:45:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n在开发前需要思考：**这个功能的哪些逻辑可以抽出成为独立的Hooks**。\n\n\nHooks核心优点：\n\n1. 方便进行逻辑复用\n2. 帮助关注分离\n\n# 自定义Hooks\n\n\n方法：声明一个名字**以use开头**的函数，且在函数内使用到了其他Hooks，如果没有使用到其他Hooks那它就是一个普通函数。\n\n\n**一方面可以实现逻辑复用，另一方便可以使代码更加语义化。**\n\n\n# 三个典型的业务场景\n\n\n## 封装通用逻辑：useAsync\n\n\n发起异步请求获取数据并显示在界面上，data，loading，error三个状态逻辑可以作为通用逻辑。\n\n\n可以自己写一下\n\n\n优点：在Hooks中可以管理当前组件的state，从而使更多的逻辑写在可重用的Hooks内，而普通的工具类是无法修改组件state地，那么就无法在数据改变时触发组件的重新渲染。\n\n\n## 监听浏览器状态：useScroll\n\n\n如：界面需要根据窗口大小变化重新布局 / 页面滚动时根据滚动位置显示「返回顶部」的按钮。\n\n\n**可以让React的组件绑定在任何可能的数据源上，这样当数据源发生变化时，组件能够重新渲染。**\n\n\n## 拆分复杂组件\n\n\n目的：保持每个函数的短小不一定是为了逻辑复用，仅仅为了业务逻辑的隔离。\n\n\n**尽量将相关的逻辑做成独立的Hook，然后在函数组件中使用这个Hooks，通过参数的传递和返回值让Hooks之间完成交互。**\n\n\nPS：所以此类Hooks可以和函数组件写在一个文件内。\n\n\n可以仔细研究一下这里的例子代码\n\n\n# 总结\n\n\n四个使用场景\n\n1. 抽取业务逻辑\n2. 封装通用逻辑\n3. 监听浏览器状态\n4. 拆分复杂组件\n\n# 思考\n\n\n将useCounter转换为更灵活的自定义增加或减少数字，如何实现？\n\n\n```typescript\nconst useCounter = () => {\n\tconst [count, setCount] = React.useState(0)\n\n\tconst increment = useCallback((step) => setCount(count + step), [count])\n\n\treturn { count, increment }\n}\n```\n\n"
  },
  {
    "id": "1866340e-4e7a-40df-aece-1e159b4f7d95",
    "slug": "1866340e4e7a40d",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-5-1866340e4e7a40dfaece1e159b4f7d95",
    "title": "⚫ React Hooks 精进 5 - 函数组件的生命周期",
    "format": "lake",
    "description": "02-05",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-26T06:53:00.000Z",
    "published_at": "2023-02-26T06:53:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 忘记Class组件的生命周期\n\n\nClass组件和函数组件是两种实现React应用的方式，需要忘记Class组件的生命周期概念。\n\n\nReact的本质：**从Model到View的映射**。\n\n\n改变组件状态的场景：\n\n- 用户操作\n- 请求返回\n\n在函数组件要思考的是当某个状态发生改变时要做什么，而不是在某个生命周期内要做什么。\n\n\n# 重新思考组件的生命周期\n\n\n## 构造函数：constructor\n\n\n在所有其他代码执行前的一次性初始化工作。\n\n\n函数组件基本上没有统一的初始化需要，因为Hooks自己会负责自己的初始化，然后可以使用useRef来标记是否执行过（useRef的数据在组件渲染过程中不被重置）。\n\n\n## 三种常用生命周期方法\n\n\ncomponentDidMount，componentWillUnmount和componentDidUpdate这几个生命周期方法都可以统一到useEffect这个Hook上（触发一个副作用，在每次render之后执行）。\n\n\n```typescript\nuseEffect(() => {\n\tconsole.log('componentDidMount + componentDidUpdat')\n\n\treturn () => {\n\t\tconsole.log('componentWillUnmount')\n\t}\n}, [deps])\n```\n\n\nuseEffect接收一个callback参数（deps），可以返回一个用于清理资源的函数。\n\n\n### 区别：\n\n1. useEffect(callback)接收的这个callback函数只在依赖项（deps）改变时执行，而componentDidUpdate在state发生改变时一定会执行，此时需要手动去判断某个状态是否发生改变。\n2. callback返回的清理函数在下一次依赖项发生变化以及组件销毁之前执行，而componentWillUnmount只在组件销毁时执行。\n\n\tPS：每次Effect执行之前都会执行用于清理上一次Effect的执行结果。\n\n\n## 实际项目使用\n\n1. 类组件和函数组件可以相互引用。\n2. Hooks很容易转换成高阶组件，并供类组件使用。\n\n# 思考\n\n\n如果想在函数组件内实现严格的componentWillUnmount即只在销毁时执行，应该如何实现。\n\n\n我的思路：就是使用空依赖项的useEffect（✅ 正确）\n\n"
  },
  {
    "id": "365de9a2-d274-438b-a51b-d4c00e3649ab",
    "slug": "365de9a2d274438",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060033Z&X-Amz-Expires=3600&X-Amz-Signature=0e01789498d35f9599d5c8f8997baca6ec9b67b495a2edaf986c7424b60b5d6e&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/004-365de9a2d274438ba51bd4c00e3649ab",
    "title": "💟 汪汪周刊 004期：怎么停止精神内耗",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-20T01:00:00.000Z",
    "published_at": "2023-02-20T01:00:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060033Z&X-Amz-Expires=3600&X-Amz-Signature=0e01789498d35f9599d5c8f8997baca6ec9b67b495a2edaf986c7424b60b5d6e&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/560bd117-80ad-4b0e-bac7-73a9319fe47e/IMG_5974.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060036Z&X-Amz-Expires=3600&X-Amz-Signature=08d7820e01256037a1712df428d5b7e38d53338fc653edce92f5592d09c52e91&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 焦糖布丁\n\n\n# 前提\n\n\n每天晚上睡觉前总会\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n\n# 工具\n\n\n# 专业技术领域\n\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 开放倒计时组件分享\n\n# 最后的碎碎念\n\n\n# 话题\n\n\n![](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "75f0d7d8-6b5b-4a5c-ac98-53df8753ad84",
    "slug": "75f0d7d86b5b4a5",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-4-Hooks-75f0d7d86b5b4a5cac9853df8753ad84",
    "title": "⚫ React Hooks 精进 4 - 内置Hooks（二）回调函数",
    "format": "lake",
    "description": "04",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-17T10:08:00.000Z",
    "published_at": "2023-02-17T10:08:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# useCallback，useMemo，useRef，useContext\n\n\n## useCallback：缓存回调函数\n\n\n函数组件中并没有一个直接的方式在多次渲染之间维持一个状态，所以一些定义在函数组件内的函数在多次渲染之间无法重用，每次都需要创建一个新的。**这样也会导致每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染。**\n\n\n思路：只有当函数参数或调用变量发生变化时，才需要重新定义一个回调函数。\n\n\n于是就有了useCallback这个Hook。\n\n\n```javascript\nuseCallback(fn, deps) // fn: 回调函数, deps: 依赖项\n```\n\n\n```javascript\nconst handleIncrement = useCallback(\n\t() => setCount(count + 1),\n\t[count]\n);\n```\n\n\n可以减少不必要的渲染，主要体现在将回调函数作为属性传给某个组件，因为如果函数被重新创建，那么组件的props就会发生变化也会导致子组件的重新渲染。\n\n\nuseMemo也是为了缓存而设计的，useCallback缓存的是一个函数，而useMemo缓存的是计算结果。\n\n\n## useMemo：缓存计算结果\n\n\n```javascript\nuseMemo(fn, deps) // fn: 计算函数, deps: 依赖项\n```\n\n\n**如果某个数据是通过其他数据计算得到，那么只有当用到的变量（依赖项）发生变化时才会重新计算。**\n\n\n```javascript\nimport React, { useState, useMemo, useEffect } from \"react\";\n\nexport default function SearchUserList() {\n  const [users, setUsers] = useState(null);\n  const [searchKey, setSearchKey] = useState(\"\");\n\n  useEffect(() => {\n    const doFetch = async () => {\n      // 组件首次加载时发请求获取用户数据\n      const res = await fetch(\"https://reqres.in/api/users/\");\n      setUsers(await res.json());\n    };\n    doFetch();\n  }, []);\n\n  const usersToShow = useMemo(() => {\n    if (!users) return null;\n    return users.data.filter((user) => user.first_name.includes(searchKey));\n  }, [users, searchKey]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={searchKey}\n        onChange={(evt) => setSearchKey(evt.target.value)}\n      />\n      <ul>\n        {usersToShow &&\n          usersToShow.length > 0 &&\n          usersToShow.map((user) => {\n            return <li key={user.id}>{user.first_name}</li>;\n          })}\n      </ul>\n    </div>\n  );\n}\n```\n\n\n可以避免一些重复计算，还可以**避免子组件的重复渲染**！\n\n\n♦️ 其实useCallback的功能其实可以用useMemo来实现。\n\n\n## useRef：在多次渲染之间共享数据\n\n\n```javascript\nconst refCon = useRef(initialValue)\n```\n\n\n可以把useRef看作是在函数组件之外创建的一个容器空间，在这个容器上，这样就可以通过唯一的current属设置的一个值，从而在函数组件的多次渲染之间共享这个值。\n\n\n```javascript\nimport React, { useState, useCallback, useRef } from \"react\";\n\nexport default function Timer() {\n  // 定义 time state 用于保存计时的累积时间\n  const [time, setTime] = useState(0);\n\n  // 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量\n  const timer = useRef(null);\n\n  // 开始计时的事件处理函数\n  const handleStart = useCallback(() => {\n    // 使用 current 属性设置 ref 的值\n    timer.current = window.setInterval(() => {\n      setTime((time) => time + 1);\n    }, 100);\n  }, []);\n\n  // 暂停计时的事件处理函数\n  const handlePause = useCallback(() => {\n    // 使用 clearInterval 来停止计时\n    window.clearInterval(timer.current);\n    timer.current = null;\n  }, []);\n\n  return (\n    <div>\n      {time / 10} seconds.\n      <br />\n      <button onClick={handleStart}>Start</button>\n      <button onClick={handlePause}>Pause</button>\n    </div>\n  );\n}\n```\n\n\n使用useRef保存的数据一般是和UI渲染无关的，因此当ref的值发生变化时是不会触发组件的重新渲染的。\n\n\n### 保存某个DOM节点的引用\n\n\n就可以利用这个保存功能，就可以在渲染界面上访问到真实的DOM节点。\n\n\n## useContext：定义全局状态\n\n\n能够让所有组件在某个组件开始的组件树上创建一个Context，这样这个组件树上的所有组件都能访问和修改这个Context。\n\n\n```javascript\nconst context = React.createContext(initialValue);\nconst value = useContext(context);\n```\n\n\ncontext具有一个Provider的属性，一般作为组件树的根组件。\n\n\n```javascript\nimport React, { useState, useContext, useCallback } from \"react\";\n\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\",\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\",\n  },\n};\n\n// 创建一个 Theme 的 Context\nconst ThemeContext = React.createContext(themes.light);\n\n// 在 Toolbar 组件中使用一个会使用 Theme 的 Button\nfunction Toolbar() {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Theme Button 中使用 useContext 来获取当前的主题\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button\n      style={{\n        background: theme.background,\n        color: theme.foreground,\n      }}\n    >\n      I am styled by theme context!\n    </button>\n  );\n}\n\n// 在 Toolbar 组件中使用一个会使用 Theme 的 Button\nexport default function () {\n  // 使用 state 来保存 theme 从而可以动态修改\n  const [theme, setTheme] = useState(\"light\");\n\n  // 切换 theme 的回调函数\n  const toggleTheme = useCallback(() => {\n    setTheme((theme) => (theme === \"light\" ? \"dark\" : \"light\"));\n  }, []);\n\n  return (\n    // 使用 theme state 作为当前 Context\n    <ThemeContext.Provider value={themes[theme]}>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n      <br />\n      <br />\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n```\n\n\n♦️ 缺点\n\n- 让调试变得困难\n- 让组件复用变得困难\n\n---\n\n\n思考：\n\n\nuseState也能够在组件的多次渲染之间共享数据，那个那个timer计时器是否能用state去保存window.setInterval()？\n\n- 可以但没必要，用useState保存的话会触发组件的重新渲染？\n- useRef结果的改变不会触发重新渲染\n"
  },
  {
    "id": "704688e7-5f5a-4f0b-b313-530793a3b01e",
    "slug": "704688e75f5a4f0",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-3-Hooks-704688e75f5a4f0bb313530793a3b01e",
    "title": "⚫ React Hooks 精进 3 - 内置Hooks（一）组件状态",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-02T09:16:00.000Z",
    "published_at": "2023-02-02T09:16:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n> 遇到需求时，直接考虑在Hooks内如何实现。\n\n\n# 内置Hooks\n\n\n## 常用Hooks\n\n- useState\n- useEffect\n- useCallback\n- useMemo\n- useRef\n- useContext\n- …\n\n## useState：让函数组件具备维持状态的能力\n\n\n在一个函数组件的多次渲染之间，这个state是共享的。\n\n\n用法：\n\n1. `useState(initialState)`：传入创建state的初始值，可以是任意类型\n2. `useState()`的返回值`[xx, setXx]`是有两个元素的数组，第一个用于读取，第二个用于设置\n\nstate是React组件非常重要的一个机制，需要遵循一个原则：**state中永远不要保存通过计算能够得到的值**：\n\n1. 从props传递过来的值；\n2. 从URL中读取的值；\n3. 从cookie，localStorage中读取的值；\n\n‼️ ：**一旦组件有自己的状态，意味着组件如果重新创建就需要有恢复状态的能力，这通常会让组件变得复杂**。\n\n\n## useEffect：执行副作用\n\n\n副作用：**一段和当前执行结果无关的代码**，比如修改函数外部变量，发起请求等，在函数组建的当次执行过程中，useEffect内执行的代码不影响渲染出来的UI。\n\n\n**useEffect是每次组件render完后判断以来并执行。**\n\n\n```javascript\nuseEffect(callback, dependencies);\n```\n\n\n如果不指定依赖项那么callback在每次函数组件执行完后都会执行，如果指定那么只有依赖项中的值发生改变才会执行。\n\n\n```javascript\nimport React, { useState, useEffect } from \"react\";\n\nfunction BlogView({ id }) {\n  // 设置一个本地 state 用于保存 blog 内容\n  const [blogContent, setBlogContent] = useState(null);\n\n  useEffect(() => {\n    // useEffect 的 callback 要避免直接的 async 函数\n    // 需要封装一下\n    const doAsync = async () => {\n      // 当 id 发生变化时，将当前内容清除以保持一致性\n      setBlogContent(null);\n      // 发起请求获取数据\n      const res = await fetch(`/blog-content/${id}`);\n      // 将获取的数据放入 state\n      setBlogContent(await res.text());\n    };\n    doAsync();\n  }, [id]); // 使用 id 作为依赖项，变化时则执行副作用\n\n  // 如果没有 blogContent 则认为是在 loading 状态\n  const isLoading = !blogContent;\n  return <div>{isLoading ? \"Loading...\" : blogContent}</div>;\n}\n```\n\n\n特殊用法：\n\n1. **没有依赖项**：每次render完一定会执行；\n2. **依赖项为空数组**：只在首次渲染执行时触发；\n3. useEffect允许**返回一个函数，用于在组件销毁时做一些清理操作**；\n\n## Hooks的依赖\n\n\n依赖项不是内置Hooks的特殊机制而是一种设计模式，有类似需求的Hooks都可以用这个模式去实现。\n\n\n⚠️ 注意：\n\n1. 依赖项内定义的变量要一定会在回调函数内使用到；\n2. 依赖项一般是一个常量数组；\n3. React是使用浅比较来对比依赖项是否发生变化，所以需要注意数组或者对象类型；\n\n## Hooks的使用规则\n\n\n### 只能在函数组建的顶级作用域内使用\n\n\n> Hooks不能在循环，条件判断或者嵌套函数内执行，而必须是在顶层。同时**Hooks在组件的多次渲染之间，必须按顺序执行。**\n\n- 所有Hook必须要被执行到\n- 必须按顺序执行\n\n### 只能在函数组件或者其他Hooks中使用\n\n\n如何在class组件内通过Hooks实现逻辑重用 → 利用高阶组件的模式，将Hooks封装成高阶组件，从而让类组件使用。\n\n\n♦️ 总结：\n\n- 在`useEffect`的毁掉函数中使用的变量，都必须在依赖项中声明；\n- Hooks不能出现在条件语句或循环内，也不能出现在return之后；\n- Hooks只能在函数组件或自定义Hooks中使用；\n\n→→ React官方提供专门用来检查Hooks是否正确被使用，`eslint-plugin-react-hooks`\n\n\n---\n\n\n问题：\n\n- 如果useEffect用的某些变量没有在依赖向内指定，会发生什么\n"
  },
  {
    "id": "29fcc859-25db-44ce-a8b3-8cc4120c4b0f",
    "slug": "29fcc85925db44c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-7-Redux-29fcc85925db44cea8b38cc4120c4b0f",
    "title": "React Hooks 精进 7 - 全局状态管理 Redux",
    "format": "lake",
    "description": "02-07",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-15T06:49:00.000Z",
    "published_at": "2023-07-15T06:49:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n**Redux是状态管理框架，基于不可变数据的机制。**\n\n\n# Redux的出现背景\n\n\n原先的数据传递：组件级别的state，从上而下的props两个状态机制。\n\n\n但是无法满足类似跨层级的组件数据共享和传递。\n\n\n## Redux Store的特点\n\n- **Redux Store是全局唯一的。**\n- **Redux Store是树状结构。**\n\n## 使用场景\n\n- 跨组件的状态共享\n- 同组件多个实例的状态共享\n\n# 基本概念\n\n- State：即Store\n- Action：用于描述发生的动作\n- Reducer：接受Action和State作为参数通过计算得到新的Store\n\n## 好处：\n\n- 保证数据的不可变性：**在Reducer内每次必须返回一个新的对象**\n- 可预测性\n- 易于调试：可以跟踪Store中数据的变化\n\n## Redux逻辑步骤\n\n- 创建store\n- 利用Action和Reducer修改Store\n- 利用subscribe监听store变化\n\n```typescript\nimport { createStore } from \"redux\";\n\nconst initStore = { value: 0 };\n\nfunction counterReducer(state = initStore, action) {\n  switch (action.type) {\n    case \"counter/incremented\":\n      return { value: state.value + 1 };\n    case \"counter/decremented\":\n      return { value: state.value - 1 };\n    default:\n      return state;\n  }\n}\n\nconst store = createStore(counterReducer)\nstore.subscribe(() => console.log(store.getState()));\n\nconst incrementAction = { type: \"counter/incremented\"}\nconst decrementAction = { type: \"counter/decremented\"}\n\nstore.dispatch(incrementAction)\nstore.dispatch(incrementAction)\nstore.dispatch(decrementAction)\n```\n\n\n# 使用方法\n\n- React组件能在依赖的Store的数据发生变化时重新render\n- 在React组件中，能够在某些时机去dispatch一个action，从而出发store的更新\n\n**需要在React内引入react-redux工具库，让React和Redux实现互通。**\n\n\n为了确保需要绑定的组件能够访问到全局唯一的Redux Store，需要利用React的Context机制去存放Store信息。\n\n\n```typescript\nimport { Provider } from 'react-redux'\n\nReactDOM.render(\n\t<Provider store={store}>\n\t\t<App />\n\t</Provider>,\n\trootElement\n)\n```\n\n\n**然后就可以利用react-redux提供的****`useSelector`****和****`useDispatch`****两个Hooks来使用Redux了。**\n\n- `useSelector`：让组件在Store的某些数据发生变化时重新render\n\n```mermaid\ngraph TD\n  Reducer --> Store\n\tStore --> View\n\tView --> Action\n\tAction --> Reducer\n```\n\n\n# 利用Redux处理异步逻辑（异步Action）\n\n\n在Store内我们不仅维护着业务数据同时维护着应用程序的状态。\n\n\nstore的主要变化：\n\n- 请求发送时：设置`state.pending = true` → 用于UI显示加载中状态\n- 请求发送成功：设置`state.pending = false, state.data = result` → 取消加载状态同时将获取的数据展示在UI上\n- 请求发送失败：设置`state.pending = false, state.error = error` → 取消加载状态，设置错误状态和信息，用于在UI上显示错误内容\n\n```typescript\nfunction DataList() {\n    const dispatch = useDispatch();\n    useEffect(() => {\n        dispatch({type: 'FETCH_START'})\n        fetch('/xxx').then(res => {\n            dispatch({type: 'FETCH_SUCCESS', data: res})\n        }).catch(err => {\n            dispatch({type: 'FETCH_ERROR', error: err})\n        })\n    }, [])\n    const data = useSelector(state => state.data)\n    const pending = useSelector(state => pending)\n    const error = useSelector(state => error)\n    if(error) return 'Error'\n    if(pending) return 'Loading...'\n    return <Table data={data} />\n}\n```\n\n\n在上述代码中使用三个同步Action完成这个异步请求的场景，这里将store完全作为一个存放数据的地方。\n\n\n发送请求获取数据并进行错误处理的逻辑是不可重用的，如果在另一个组件中也使用同样的请求就需要在组件内重新实现一遍。\n\n\n因此Redux提供了**middleware**机制可以巧妙地实现异步Action的概念。\n\n\nmiddleware可以让你提供一个拦截器在reducer处理action之前被调用，在拦截器内可以自由地处理获得的action。\n\n\n**Action → Middleware → Reducer**\n\n\n然后Redux提供了react-thunk的中间件，它如果发现接收到的action是一个函数，那么就不会传递给reducer而是执行这个函数，并把dispatch作为参数传给这个函数。\n\n\n```typescript\nimport {createStore, applyMiddleware} from 'react'\nimport thunkMiddleware from 'redux-thunk'\nimport rootReducer from './reducer'\n\nconst composedEnhancer = applyMiddleware(thunkMiddleware)\nconst store = createStore(rootReducer, composeEnhancer)\n```\n\n\n```typescript\nfunction fetchData() {\n    return dispatch => {\n        dispatch({type: 'FETCH_START'})\n        fetch('/xxx').then(res => {\n            dispatch({type: 'FETCH_SUCCESS', data: res})\n        }).catch(err => {\n            dispatch({type: 'FETCH_ERROR', error: err})\n        })\n    }\n}\n```\n\n\n```javascript\nfunction DataList2() {\n    const dispatch = useDispatch()\n    dispatch(fetchData())\n}\n```\n\n\n**通过这种方式就可以实现异步请求的重用，这一套结合redux-thunk中间件的机制称之为异步Action（更像是Redux的使用模式，通过组合使用同步Action用一致的方式提供处理异步逻辑的方案）。**\n\n\n# 思考题\n\n\n只考虑Redux，如何在计数器内实现指定的变量值。\n\n"
  },
  {
    "id": "f92c3fda-f36c-4ac7-a7b6-6ef18822baf7",
    "slug": "f92c3fdaf36c4ac",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-11-f92c3fdaf36c4ac7a7b66ef18822baf7",
    "title": "React Hooks 精进 11 - 创建自定义事件",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-06T07:19:00.000Z",
    "created_at": "2023-08-05T08:10:00.000Z",
    "published_at": "2023-08-05T08:10:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\nprops是组件之间通信的基础。\n\n\n# 在React中使用原生事件\n\n\n## React原生事件的原理：合成事件\n\n\n由于虚拟DOM的存在，在React中即使绑定一个事件到原生的DOM节点，事件也并不是绑定在对应的节点上，而是**所有的事件都是绑定在根节点上**，然后由React统一监听和管理，获取事件后分发到具体的虚拟DOM节点上。（浏览器事件的冒泡模型，无论事件是在哪个节点被触发，React都可以通过事件的srcElement这个属性知道他从哪个节点发出的）。\n\n\n## 创建自定义事件\n\n\n对于自定义组件，组件内的自定义事件也是非常重要的一部分，虽然自定义事件和原生事件看上去相似，但机制完全不一样：\n\n- 原生事件是浏览器的机制\n- 自定义事件则是纯粹的组件自己的行为，本质是一种**回调函数机制**\n\n习惯上会将这样的回调函数命名为**onSomething**。\n\n\n## 使用Hooks封装键盘事件\n\n\n比如在一个表格页面支持左右键进行翻页的功能，那么需要我们在useEffect内做window。addEvent Listener，然后在返回回调函数内remove。\n\n\n如果使用Hook来实现，就可以在多个组件中使用了。\n\n\n```typescript\nconst useKeyPress = (domeNode = document.body) => {\n\tconst [key, setKey] = useState(null);\n\tuseEffect(() => {\n\t\tdomNode.addEventListener('keypress', handleKeyPress)\n\t\treturn () => {\n\t\t\tdomNode.removeEventListener('keypress', handleKeyPress)\n\t\t}\n\t}, [domNode)\n}\n```\n\n\n# 思考题\n\n\n如何用Hook实现监听两个按键同时按下？\n\n\n同时按下两个按钮会触发两个keyPress事件，可以通过数组存储key，在keyup的时候清空数组。\n\n"
  },
  {
    "id": "d51b7809-92d6-4506-84e0-c7ec9ae37b7a",
    "slug": "d51b780992d6450",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-10-d51b780992d6450684e0c7ec9ae37b7a",
    "title": "React Hooks 精进 10 - 函数组件设计模式",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-08-05T06:53:00.000Z",
    "published_at": "2023-08-05T06:53:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 函数组件设计模式\n\n\n保证状态的唯一数据源，语义化的拆分复杂组件都是一些设计模式。\n\n\n## 容器模式：实现按条件执行Hooks\n\n\n注意点：**Hooks必须在顶层作用域调用（因为React需要在函数组件内部维护所用到的Hooks的状态）**。\n\n\n比如有一个对话框组件，我们只想要它在组件出现时执行业务逻辑，那么就可以在Hook内部判断如果不显示则返回null。\n\n\n```typescript\nfunction UserModal(visible) {\n\tif(!visible) return null;\n\t\n\tuseEffect(......)\n\n\treturn <div>...</div>\n}\n```\n\n\n但是显然这样是无法通过编译的，因为在return之后使用了useEffect这个Hook。\n\n\n所以这里需要用到一个**容器模式**，就是**把条件贩毒案的结果放在两个组件之中，确保真正的render UI的组件收到的所有属性都是有值的**。\n\n\n```typescript\nfunction UserModalWrapper(visible) {\n\tif(!visible) return null;\n\n\treturn <UserModal visible />\n}\n```\n\n\n就是在原来的函数组件外增加一个容器，这样就可以实现对应的条件渲染。\n\n\n这样的好处是可以在根组件下减少条件判断语句，可以确保每个组件尽量短小，更便于阅读和维护。\n\n\n也可以将一些非render UI相关的逻辑自包含进hooks内。\n\n\n## 使用render props模式重用UI逻辑\n\n\n**把一个render函数作为属性传递给某个组件，由这个组件去执行这个函数从而render实际的内容。**\n\n\n在函数组件内hooks只能用作数据逻辑的重用，而涉及到UI就有些麻烦，这时候就可以尝试render props这个设计模式。\n\n\n使用render props如何封装一个计数器，让他可以在不同的组件内使用。\n\n\n```typescript\nfunction CounterRenderProps({ children }) {\n\tconst [count, setCount] = useState(0);\n\tconst change = useCallback((step = 1) => {\n\t\tsetCount( count + step);\n\t}, [count])\n\t\n\treturn children({count, change})\n}\n```\n\n\n```typescript\n// 调用时\nfunction Counter() {\n\treturn <CounterRenderProps>\n\t\t{({count, change}) => {\n\t\t\treturn <div>....</div>\n\t\t}}\n\t</CounterRenderProps>\n}\n```\n\n\n这里就是利用了children的这个特殊属性，也就是组件开始tag和结束tag之间的内容其实都会作为children这个属性传递给组件的。\n\n\n很显然使用Hooks的方式是更简洁的，但是还是**需要掌握Render props这种设计模式**。\n\n\n**这里需要研究老师给出的这个ListWithMore的例子。**\n\n"
  },
  {
    "id": "86b2af18-6c26-415b-a00c-1efc46ecb9ff",
    "slug": "86b2af186c26415",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/Chapter-1-86b2af186c26415ba00c1efc46ecb9ff",
    "title": "Chapter 1",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-06T08:33:00.000Z",
    "created_at": "2023-07-27T14:59:00.000Z",
    "published_at": "2023-07-27T14:59:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [日语]<br />categories: [日语初级]<br />cover: null\n\n---\n\nundefined"
  },
  {
    "id": "fc979d69-7f5d-45c3-b8a2-883601a91989",
    "slug": "fc979d697f5d45c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-9-fc979d697f5d45c3b8a2883601a91989",
    "title": "React Hooks 精进 9 - 异步处理：向服务端发送请求",
    "format": "lake",
    "description": "03-09",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-15T13:47:00.000Z",
    "published_at": "2023-07-15T13:47:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 实现自己的API Client\n\n\n在项目内实现异步请求时第一个事情就是创建自己的API Client，之后所有的请求都可以通过这个Client发出去。\n\n- 一些通用的header\n- 服务器地址的配置：比如可以根据当前环境判断连接的服务器地址\n- 请求未认证的处理\n\n# 使用Hooks思考异步请求：封装远程资源\n\n\n对于一个get类型的API，可以将它看成一个远程的数据源：\n\n- Data\n- Error\n- Pending\n\n比起将请求直接写在组件内部，迁移到一个Hook内可以把组件的表现层逻辑写得更加简洁，将API的调用看作一个数据获取。\n\n\n之后只需要将获取到的数据映射到JSX并显示出来即可。\n\n\n这个模式**仅适用于get请求逻辑**，对于其他类型可查看第六节的useAsync。\n\n\n# 多个API调用：处理并发或者串行请求\n\n\n比如一个博客文章展示页面的场景，这里需要三个请求：\n\n- 文章详情\n- 作者信息，包括名字，头像等\n- 文章的评论\n\n此时包含了并发和串行的场景，文章详情和评论可以并发请求，作者的信息需要等文章内容返回才能知道作者ID，这是串行场景。\n\n\n```typescript\n// 传统场景\nconst [article, comments] = await Promise.all([\n\tfetchArticle(id)\n\tfetchComments(id)\n])\nconst user = await fetchUser(article.user_id)\n```\n\n\nReact函数组件是一个同步函数，没有办法直接使用await这样的同步方法，而是需要将请求通过副作用去触发。\n\n\n此时需要回到React的本质——状态驱动UI。\n\n\n**可以从状态变化的角度去组织异步调用，通过不同的状态组合来实现异步请求的逻辑。**\n\n\n此时的实现思路：\n\n- 组件首次渲染，需要两个副作用去获取文章和评论\n- 组件首次渲染，作者ID不存在不发送任何请求\n- 文章内容返回，开始发送请求作者信息\n- 展示作者信息\n\n```typescript\nconst {data: article, loading, error} = useArticle(id)\nconst {data: comments} = useComments(id)\nconst {data: user} = useUser(article?.user_id)\n// 在useUser内增加一个user_id的依赖项和判断\n```\n\n\n# 思考\n\n1. 每次调用useArticle这个Hook就会触发副作用去获取数据，但是有时候需要组件自动获取，有些需要点击某个按钮才去获取，此时如何去设计这个Hook？\n\n\t我的回答：增加一个是否请求的deps？\n\n2. Hook都是使用useState保存了状态数据，意味着状态的范围限定在组件内部，组件销毁后数据就没了，此时希望数据直接缓存到全部状态该如何做？\n\n\t我的回答：使用redux或者localStorage？\n\n"
  },
  {
    "id": "d45a2962-7dc2-44c4-b766-ad01ece3024b",
    "slug": "d45a29627dc244c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-8-d45a29627dc244c4b766ad01ece3024b",
    "title": "React Hooks 精进 8 - 复杂状态处理",
    "format": "lake",
    "description": "03-08",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-15T13:13:00.000Z",
    "published_at": "2023-07-15T13:13:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 状态一致性\n\n\n**React开发就是复杂应用程序状态的管理和开发。**\n\n\n# 原则一：保证状态最小化\n\n\n在保证State完整性的同时也要保证它的最小化，如果某些数据能从已有的state中计算得到那么不要把计算的结果存到state内。\n\n\n按照React的状态驱动UI的思想，开发时第一步要**考虑整个功能有哪几个状态**。\n\n\nReact提供的`useMemo`这个Hook就可以缓存计算的结果。\n\n\n# 原则二：避免中间状态，确保唯一数据源\n\n\n在有些场景下，比如原始状态数据来自某个外部数据源，非state或者props，冗余状态就没有那么明显，此时需要准确定位状态的数据源并在开发中确保它是唯一的数据源。\n\n\n**这里的例子是URL上查询关键词同步的场景。**\n\n\n# 实战演练：创建自定义受控组件\n\n\n## 受控组件：组件的展示完全由传入的属性决定。\n\n\n## 非受控组件：表单组件可以有自己的内部状态且他的展示值不受控。\n\n\n## 自定义受控组件：\n\n- 避免多余的状态：不需要在自定义组件内部去定义状态用于保存数据\n- 找到准确的唯一数据源：准确且唯一的来源就是福组件传递进来的状态\n\n# 思考\n\n\n如何实现useSearchParams（用于监听查询参数的变化）这个Hook？\n\n\nhistory.pushState不会出发页面重新渲染，所以通常只能获取第一次的URL参数，如果URL参数发生变化无法查询到，所以可以通过patch的方法来监听url变化。\n\n"
  },
  {
    "id": "3666e4e0-a1f0-4db5-a818-76ac2e87c481",
    "slug": "3666e4e0a1f04db",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-6-3666e4e0a1f04db5a81876ac2e87c481",
    "title": "React Hooks 精进 6 - 典型的使用场景",
    "format": "lake",
    "description": "02-06",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-07-10T14:45:00.000Z",
    "published_at": "2023-07-10T14:45:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n在开发前需要思考：**这个功能的哪些逻辑可以抽出成为独立的Hooks**。\n\n\nHooks核心优点：\n\n1. 方便进行逻辑复用\n2. 帮助关注分离\n\n# 自定义Hooks\n\n\n方法：声明一个名字**以use开头**的函数，且在函数内使用到了其他Hooks，如果没有使用到其他Hooks那它就是一个普通函数。\n\n\n**一方面可以实现逻辑复用，另一方便可以使代码更加语义化。**\n\n\n# 三个典型的业务场景\n\n\n## 封装通用逻辑：useAsync\n\n\n发起异步请求获取数据并显示在界面上，data，loading，error三个状态逻辑可以作为通用逻辑。\n\n\n可以自己写一下\n\n\n优点：在Hooks中可以管理当前组件的state，从而使更多的逻辑写在可重用的Hooks内，而普通的工具类是无法修改组件state地，那么就无法在数据改变时触发组件的重新渲染。\n\n\n## 监听浏览器状态：useScroll\n\n\n如：界面需要根据窗口大小变化重新布局 / 页面滚动时根据滚动位置显示「返回顶部」的按钮。\n\n\n**可以让React的组件绑定在任何可能的数据源上，这样当数据源发生变化时，组件能够重新渲染。**\n\n\n## 拆分复杂组件\n\n\n目的：保持每个函数的短小不一定是为了逻辑复用，仅仅为了业务逻辑的隔离。\n\n\n**尽量将相关的逻辑做成独立的Hook，然后在函数组件中使用这个Hooks，通过参数的传递和返回值让Hooks之间完成交互。**\n\n\nPS：所以此类Hooks可以和函数组件写在一个文件内。\n\n\n可以仔细研究一下这里的例子代码\n\n\n# 总结\n\n\n四个使用场景\n\n1. 抽取业务逻辑\n2. 封装通用逻辑\n3. 监听浏览器状态\n4. 拆分复杂组件\n\n# 思考\n\n\n将useCounter转换为更灵活的自定义增加或减少数字，如何实现？\n\n\n```typescript\nconst useCounter = () => {\n\tconst [count, setCount] = React.useState(0)\n\n\tconst increment = useCallback((step) => setCount(count + step), [count])\n\n\treturn { count, increment }\n}\n```\n\n"
  },
  {
    "id": "1866340e-4e7a-40df-aece-1e159b4f7d95",
    "slug": "1866340e4e7a40d",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-5-1866340e4e7a40dfaece1e159b4f7d95",
    "title": "React Hooks 精进 5 - 函数组件的生命周期",
    "format": "lake",
    "description": "02-05",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-26T06:53:00.000Z",
    "published_at": "2023-02-26T06:53:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 忘记Class组件的生命周期\n\n\nClass组件和函数组件是两种实现React应用的方式，需要忘记Class组件的生命周期概念。\n\n\nReact的本质：**从Model到View的映射**。\n\n\n改变组件状态的场景：\n\n- 用户操作\n- 请求返回\n\n在函数组件要思考的是当某个状态发生改变时要做什么，而不是在某个生命周期内要做什么。\n\n\n# 重新思考组件的生命周期\n\n\n## 构造函数：constructor\n\n\n在所有其他代码执行前的一次性初始化工作。\n\n\n函数组件基本上没有统一的初始化需要，因为Hooks自己会负责自己的初始化，然后可以使用useRef来标记是否执行过（useRef的数据在组件渲染过程中不被重置）。\n\n\n## 三种常用生命周期方法\n\n\ncomponentDidMount，componentWillUnmount和componentDidUpdate这几个生命周期方法都可以统一到useEffect这个Hook上（触发一个副作用，在每次render之后执行）。\n\n\n```typescript\nuseEffect(() => {\n\tconsole.log('componentDidMount + componentDidUpdat')\n\n\treturn () => {\n\t\tconsole.log('componentWillUnmount')\n\t}\n}, [deps])\n```\n\n\nuseEffect接收一个callback参数（deps），可以返回一个用于清理资源的函数。\n\n\n### 区别：\n\n1. useEffect(callback)接收的这个callback函数只在依赖项（deps）改变时执行，而componentDidUpdate在state发生改变时一定会执行，此时需要手动去判断某个状态是否发生改变。\n2. callback返回的清理函数在下一次依赖项发生变化以及组件销毁之前执行，而componentWillUnmount只在组件销毁时执行。\n\n\tPS：每次Effect执行之前都会执行用于清理上一次Effect的执行结果。\n\n\n## 实际项目使用\n\n1. 类组件和函数组件可以相互引用。\n2. Hooks很容易转换成高阶组件，并供类组件使用。\n\n# 思考\n\n\n如果想在函数组件内实现严格的componentWillUnmount即只在销毁时执行，应该如何实现。\n\n\n我的思路：就是使用空依赖项的useEffect（✅ 正确）\n\n"
  },
  {
    "id": "365de9a2-d274-438b-a51b-d4c00e3649ab",
    "slug": "365de9a2d274438",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075034Z&X-Amz-Expires=3600&X-Amz-Signature=bafd7a122ebb21ae0908ddc2399476e922d27d8a2dfd34bc15726458daf2bbc2&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/004-365de9a2d274438ba51bd4c00e3649ab",
    "title": "汪汪周刊 004期：怎么停止精神内耗",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-20T01:00:00.000Z",
    "published_at": "2023-02-20T01:00:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075034Z&X-Amz-Expires=3600&X-Amz-Signature=bafd7a122ebb21ae0908ddc2399476e922d27d8a2dfd34bc15726458daf2bbc2&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![IMG_5974.jpg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/560bd117-80ad-4b0e-bac7-73a9319fe47e/IMG_5974.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075035Z&X-Amz-Expires=3600&X-Amz-Signature=13ba4657dec0096875da8adad0716b1c278627da72129dcef694c1d75e6f57d3&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 焦糖布丁\n\n\n# 前提\n\n\n每天晚上睡觉前总会\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n\n# 工具\n\n\n# 专业技术领域\n\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 开放倒计时组件分享\n\n# 最后的碎碎念\n\n\n# 话题\n\n\n![9f144b95fa5e7e2b4105f7bbd6a511e4.jpg](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "75f0d7d8-6b5b-4a5c-ac98-53df8753ad84",
    "slug": "75f0d7d86b5b4a5",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-4-Hooks-75f0d7d86b5b4a5cac9853df8753ad84",
    "title": "React Hooks 精进 4 - 内置Hooks（二）回调函数",
    "format": "lake",
    "description": "04",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-17T10:08:00.000Z",
    "published_at": "2023-02-17T10:08:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# useCallback，useMemo，useRef，useContext\n\n\n## useCallback：缓存回调函数\n\n\n函数组件中并没有一个直接的方式在多次渲染之间维持一个状态，所以一些定义在函数组件内的函数在多次渲染之间无法重用，每次都需要创建一个新的。**这样也会导致每次创建新函数的方式会让接收事件处理函数的组件，需要重新渲染。**\n\n\n思路：只有当函数参数或调用变量发生变化时，才需要重新定义一个回调函数。\n\n\n于是就有了useCallback这个Hook。\n\n\n```javascript\nuseCallback(fn, deps) // fn: 回调函数, deps: 依赖项\n```\n\n\n```javascript\nconst handleIncrement = useCallback(\n\t() => setCount(count + 1),\n\t[count]\n);\n```\n\n\n可以减少不必要的渲染，主要体现在将回调函数作为属性传给某个组件，因为如果函数被重新创建，那么组件的props就会发生变化也会导致子组件的重新渲染。\n\n\nuseMemo也是为了缓存而设计的，useCallback缓存的是一个函数，而useMemo缓存的是计算结果。\n\n\n## useMemo：缓存计算结果\n\n\n```javascript\nuseMemo(fn, deps) // fn: 计算函数, deps: 依赖项\n```\n\n\n**如果某个数据是通过其他数据计算得到，那么只有当用到的变量（依赖项）发生变化时才会重新计算。**\n\n\n```javascript\nimport React, { useState, useMemo, useEffect } from \"react\";\n\nexport default function SearchUserList() {\n  const [users, setUsers] = useState(null);\n  const [searchKey, setSearchKey] = useState(\"\");\n\n  useEffect(() => {\n    const doFetch = async () => {\n      // 组件首次加载时发请求获取用户数据\n      const res = await fetch(\"https://reqres.in/api/users/\");\n      setUsers(await res.json());\n    };\n    doFetch();\n  }, []);\n\n  const usersToShow = useMemo(() => {\n    if (!users) return null;\n    return users.data.filter((user) => user.first_name.includes(searchKey));\n  }, [users, searchKey]);\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={searchKey}\n        onChange={(evt) => setSearchKey(evt.target.value)}\n      />\n      <ul>\n        {usersToShow &&\n          usersToShow.length > 0 &&\n          usersToShow.map((user) => {\n            return <li key={user.id}>{user.first_name}</li>;\n          })}\n      </ul>\n    </div>\n  );\n}\n```\n\n\n可以避免一些重复计算，还可以**避免子组件的重复渲染**！\n\n\n♦️ 其实useCallback的功能其实可以用useMemo来实现。\n\n\n## useRef：在多次渲染之间共享数据\n\n\n```javascript\nconst refCon = useRef(initialValue)\n```\n\n\n可以把useRef看作是在函数组件之外创建的一个容器空间，在这个容器上，这样就可以通过唯一的current属设置的一个值，从而在函数组件的多次渲染之间共享这个值。\n\n\n```javascript\nimport React, { useState, useCallback, useRef } from \"react\";\n\nexport default function Timer() {\n  // 定义 time state 用于保存计时的累积时间\n  const [time, setTime] = useState(0);\n\n  // 定义 timer 这样一个容器用于在跨组件渲染之间保存一个变量\n  const timer = useRef(null);\n\n  // 开始计时的事件处理函数\n  const handleStart = useCallback(() => {\n    // 使用 current 属性设置 ref 的值\n    timer.current = window.setInterval(() => {\n      setTime((time) => time + 1);\n    }, 100);\n  }, []);\n\n  // 暂停计时的事件处理函数\n  const handlePause = useCallback(() => {\n    // 使用 clearInterval 来停止计时\n    window.clearInterval(timer.current);\n    timer.current = null;\n  }, []);\n\n  return (\n    <div>\n      {time / 10} seconds.\n      <br />\n      <button onClick={handleStart}>Start</button>\n      <button onClick={handlePause}>Pause</button>\n    </div>\n  );\n}\n```\n\n\n使用useRef保存的数据一般是和UI渲染无关的，因此当ref的值发生变化时是不会触发组件的重新渲染的。\n\n\n### 保存某个DOM节点的引用\n\n\n就可以利用这个保存功能，就可以在渲染界面上访问到真实的DOM节点。\n\n\n## useContext：定义全局状态\n\n\n能够让所有组件在某个组件开始的组件树上创建一个Context，这样这个组件树上的所有组件都能访问和修改这个Context。\n\n\n```javascript\nconst context = React.createContext(initialValue);\nconst value = useContext(context);\n```\n\n\ncontext具有一个Provider的属性，一般作为组件树的根组件。\n\n\n```javascript\nimport React, { useState, useContext, useCallback } from \"react\";\n\nconst themes = {\n  light: {\n    foreground: \"#000000\",\n    background: \"#eeeeee\",\n  },\n  dark: {\n    foreground: \"#ffffff\",\n    background: \"#222222\",\n  },\n};\n\n// 创建一个 Theme 的 Context\nconst ThemeContext = React.createContext(themes.light);\n\n// 在 Toolbar 组件中使用一个会使用 Theme 的 Button\nfunction Toolbar() {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\n// 在 Theme Button 中使用 useContext 来获取当前的主题\nfunction ThemedButton() {\n  const theme = useContext(ThemeContext);\n  return (\n    <button\n      style={{\n        background: theme.background,\n        color: theme.foreground,\n      }}\n    >\n      I am styled by theme context!\n    </button>\n  );\n}\n\n// 在 Toolbar 组件中使用一个会使用 Theme 的 Button\nexport default function () {\n  // 使用 state 来保存 theme 从而可以动态修改\n  const [theme, setTheme] = useState(\"light\");\n\n  // 切换 theme 的回调函数\n  const toggleTheme = useCallback(() => {\n    setTheme((theme) => (theme === \"light\" ? \"dark\" : \"light\"));\n  }, []);\n\n  return (\n    // 使用 theme state 作为当前 Context\n    <ThemeContext.Provider value={themes[theme]}>\n      <button onClick={toggleTheme}>Toggle Theme</button>\n      <br />\n      <br />\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n```\n\n\n♦️ 缺点\n\n- 让调试变得困难\n- 让组件复用变得困难\n\n---\n\n\n思考：\n\n\nuseState也能够在组件的多次渲染之间共享数据，那个那个timer计时器是否能用state去保存window.setInterval()？\n\n- 可以但没必要，用useState保存的话会触发组件的重新渲染？\n- useRef结果的改变不会触发重新渲染\n"
  },
  {
    "id": "f232c878-e4f8-4496-9d85-9320f7c192d0",
    "slug": "f232c878e4f8449",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075036Z&X-Amz-Expires=3600&X-Amz-Signature=57e3b2e0be65b5508f7eb17989fe7cf3f145f055aefcb83ceb072fa30c060668&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/003-f232c878e4f844969d859320f7c192d0",
    "title": "汪汪周刊 003期：如何突破自己的学习瓶颈",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-13T01:00:00.000Z",
    "published_at": "2023-02-13T01:00:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b3dcc974-bb70-4c35-90e9-7f1e6273387e/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075036Z&X-Amz-Expires=3600&X-Amz-Signature=57e3b2e0be65b5508f7eb17989fe7cf3f145f055aefcb83ceb072fa30c060668&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![IMG_6345.jpg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/b92fc805-affe-49a2-859c-d44855a2cca3/IMG_6345.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075036Z&X-Amz-Expires=3600&X-Amz-Signature=29270609f4d9a6a41bf976e76bc324193d814d6ebe7172fda08604bd617bcd85&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 星空葡萄\n\n\n# 前提\n\n\n前几天在逛掘金的时候，看到了一篇大哥写的文章《**如何突破技术瓶颈（适合P6以下**）》，特别有感触，其实毕业后没多久就碰上了疫情导致在工作上一直处于舒适圈也没有突破，一直想学习精进也总是三分热度找不准方向。（在后面会分享该文章部分内容）\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n- 本周比较忙，没有太多的时间去更新和学习，只能尽量保证一周一更。\n- 对了我在FlowUs上开了一个线上自习室，欢迎大家和我一起学习打卡！有兴趣可以填写以下报名表！\n\n![IMG_6277.jpg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/a75bc9e0-a3f0-436c-99e0-6ff9e525ca97/IMG_6277.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075036Z&X-Amz-Expires=3600&X-Amz-Signature=9abf5205f065bb7d16c43ef8fd01fa98cdedbccc91cbd4fb22a5080c3af5f958&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n# 工具\n\n- **ChatGPT 客户端，支持 Mac、Windows、Linux。**[https://github.com/lencx/ChatGPT#-downloads](https://github.com/lencx/ChatGPT#-downloads)\n- **Everything，**在日常工作中由于文件夹越来越多，时常碰到找不到文件夹。Everything是一款Windows系统的文件搜索工具，通过它可以快速查找电脑中的文件以及文件位置，真正实现全盘搜索\n\n# 专业技术领域\n\n- **如何突破技术瓶颈（适合P6以下**）》by 孟祥_成都\n\t- 确立自己的具体发展方向\n\t- 一步步接触比自己能力更高层次的代码\n\t- 输入额外的知识储备\n\t- 工作勇于走出舒适圈\n- • React 计划 signal 功能。\n\n\t> We might add a signals-like primitive to React but I don’t think it’s a great way to write UI code. It’s great for performance. But I prefer React’s model where you pretend the whole thing is recreated every time. Our plan is to use a compiler to achieve comparable performance.\n\n- [**Modularizing React Applications with Established UI Patterns**](https://martinfowler.com/articles/modularizing-react-apps.html)**`英文`****：如何用成熟的 UI 模式把 React 应用模块化。**\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 这周开放组件分享。\n\n# 最后的碎碎念\n\n- 不知不觉已经工作第5个年头了，但是回头看来自己还是一无所获，没有优秀的专业能力，没有学习热情，每天还是在浑浑噩噩，看到别人满满的GitHub commits还是会羡慕，但是自己又很难迈出那一步。\n\n# 话题\n\n\n大家都工作了吗？你们对自己以后的职业发展有规划吗？\n\n\n![9f144b95fa5e7e2b4105f7bbd6a511e4.jpg](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "06e490bd-5265-4fc2-a756-879420a31442",
    "slug": "06e490bd52654fc",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://s3.us-west-2.amazonaws.com/secure.notion-static.com/027d25c5-d19d-489a-a912-3504f759624a/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075036Z&X-Amz-Expires=3600&X-Amz-Signature=4f93a211f1f9ec34db57f72dabc134a469063d4145b7538dc0fbb63c4e59fe18&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/002-06e490bd52654fc2a756879420a31442",
    "title": "汪汪周刊 002期：如何保持稳定输出",
    "format": "lake",
    "description": "偷懒",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-06T02:55:00.000Z",
    "published_at": "2023-02-06T02:55:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://s3.us-west-2.amazonaws.com/secure.notion-static.com/027d25c5-d19d-489a-a912-3504f759624a/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075036Z&X-Amz-Expires=3600&X-Amz-Signature=4f93a211f1f9ec34db57f72dabc134a469063d4145b7538dc0fbb63c4e59fe18&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![41DE8900-07B8-458A-ABE5-FF511EFED51D.jpeg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0889d968-052a-4039-8def-343395a7beca/41DE8900-07B8-458A-ABE5-FF511EFED51D.jpeg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075037Z&X-Amz-Expires=3600&X-Amz-Signature=23853045cb9c0104a72f9eab839fb45393457fb6d4ce8281ad044978aa1f7990&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 锡兰牛乳茶\n\n\n# 前提\n\n\n我今年的打算是可以有稳定的输入输出，不要再三分热度，但是如何保持稳定的输入输出是一个问题。\n\n\n还有很多人正常输入是没问题的但是不会输入，就像我知识在脑子里但是需要去传达给别人的时候不会组织语言，这都是我今年想要训练自己的方面。\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n- 谷歌将推出ChatGPT竞争对手Bard，Bard是建立在谷歌现有的大型语言模型Lamda的基础上。\n- 技术写作坚持不下去怎么办，可以看张鑫旭大佬的这篇文章[《执行：坚持不下去，怎么办？》](https://juejin.cn/book/7184663814950879270/section/7184824069563351043)，他还有[**技术写作指南**](https://juejin.cn/book/7184663814950879270)这个专栏，等有时间可以购买看一下。\n\n# 工具\n\n- [https://www.galmoe.com/](https://www.galmoe.com/)：提取B站封面的网站，输入视频的bv号就可以下载视频封面\n\n\t![%E6%88%AA%E5%B1%8F2023-02-09_18.40.45.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/c0f46c85-be26-4bf5-b706-ec286aacf8e7/%E6%88%AA%E5%B1%8F2023-02-09_18.40.45.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075038Z&X-Amz-Expires=3600&X-Amz-Signature=f9e304f831c7017f74b755851849ad3959bd58b4c32ff2e2e7473afd77f4d66c&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n- [https://notion2charts.com/](https://notion2charts.com/)：可以关联Notion数据库制作图表，但是非会员只能创建一个\n\n\t![notion2charts-hero-image.png](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/38705b7d-ae75-4821-866d-15bf86d6c320/notion2charts-hero-image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075039Z&X-Amz-Expires=3600&X-Amz-Signature=b6886dece7ab285a379dc02ad19e03485767fa651095038bf7cdf899b619c481&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n# 专业技术领域\n\n- `英文`尤雨溪大大的2022年终复盘：[https://blog.vuejs.org/posts/2022-year-in-review.html](https://blog.vuejs.org/posts/2022-year-in-review.html)\n\t- 之前上学和刚毕业的时候接触的技术栈都是Vue，自从换了公司换成React了之后很久没关注过Vue的更新了，之前好像是刚更新Vue3的时候使用了一下，当初可是很热衷于研究Vue源码，后面还得找时间研究研究。\n- `英文`10 Web Development Trends in 2023（2023 年 10 大 Web 发展趋势）：[https://www.robinwieruch.de/web-development-trends/](https://www.robinwieruch.de/web-development-trends/)\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 目前只更新了几个组件，但是还没有正式开放分享，这周尽量完成并公开分享\n- 本周更新一个模版——记账本，下周还会再更新一个——减肥计划模版\n\n# 最后的碎碎念\n\n- 02/06，没想到土耳其一天内发生了2次7.8级的地震，也看到了大唐哥被埋在酒店的新闻，我真的很爱非正式会谈，他的`in my room, on my bed, with my partner`这个梗真的很好笑，有种身边的人发生意外的感觉😭。非正式会谈真的很好看，没有看过的同学可以看一下也是在B站。\n- 终于排到`Notion AI`了，接下去就让它给你讲个故事和回答一下本周的话题吧\n\t- 这是一个关于一只小猪的故事，这只小猪有三个兄弟，他们一起住在一个小屋里，每天都很开心快乐。但是有一天，有一只大灰狼来了，想要吃掉这三只小猪，所以他们三兄弟就开始挖穴，把小猪们藏起来，这就是他们的安全之所。大灰狼看到小猪们挖穴，就渐渐地失去信心，然后就再也没有出现过。最后，小猪们平安无事，每天都很开心快乐。\n\t- 有时候，学习的热情会渐渐减弱，这是很正常的。但是有一些方法可以帮助我们保持下去，比如：\n\t\t- 寻找激励：学习需要有激励，找到自己喜欢的东西，比如一个梦想，一个目标，或者一个崇拜的人物，然后把它作为学习的动力，去向它努力奋斗，这样就可以保持热情。\n\t\t- 找到适合自己的学习方法：每个人都有自己适合的学习方法，要找到自己最适合的学习方法，比如有的人比较适合用看书的方式来学习，有的人比较适合用视频的方式来学习，有的人比较适合用练习的方式来学习，找到自己最适合的学习方法，就可以让学习的热情持续下去。\n\t\t- 分享学习心得：分享学习心得是一个很好的方式，它可以让我们及时发现自己的不足之处，及时补充，也可以让我们更加深入地理解自己学习的内容，有助于提高学习能力，也可以让我们在学习的过程中得到更多的收获，从而提高学习的热情。\n\n\t\t通过以上几点，我们可以保持良好的学习热情，更好地完成学习任务。\n\n- 02/10，凌晨觉得很不安睡不着，每天都在搜索唐大哥的消息，一直刷实时的微博就希望能有好消息，可是没想到等来的却是坏消息，真的很难过，就像身边的朋友离开了一样。\n\n# 话题\n\n\n你平时会通过什么方式保持学习和分享热情？\n\n\n![9f144b95fa5e7e2b4105f7bbd6a511e4.jpg](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "704688e7-5f5a-4f0b-b313-530793a3b01e",
    "slug": "704688e75f5a4f0",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-3-Hooks-704688e75f5a4f0bb313530793a3b01e",
    "title": "React Hooks 精进 3 - 内置Hooks（一）组件状态",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-02-02T09:16:00.000Z",
    "published_at": "2023-02-02T09:16:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n> 遇到需求时，直接考虑在Hooks内如何实现。\n\n\n# 内置Hooks\n\n\n## 常用Hooks\n\n- useState\n- useEffect\n- useCallback\n- useMemo\n- useRef\n- useContext\n- …\n\n## useState：让函数组件具备维持状态的能力\n\n\n在一个函数组件的多次渲染之间，这个state是共享的。\n\n\n用法：\n\n1. `useState(initialState)`：传入创建state的初始值，可以是任意类型\n2. `useState()`的返回值`[xx, setXx]`是有两个元素的数组，第一个用于读取，第二个用于设置\n\nstate是React组件非常重要的一个机制，需要遵循一个原则：**state中永远不要保存通过计算能够得到的值**：\n\n1. 从props传递过来的值；\n2. 从URL中读取的值；\n3. 从cookie，localStorage中读取的值；\n\n‼️ ：**一旦组件有自己的状态，意味着组件如果重新创建就需要有恢复状态的能力，这通常会让组件变得复杂**。\n\n\n## useEffect：执行副作用\n\n\n副作用：**一段和当前执行结果无关的代码**，比如修改函数外部变量，发起请求等，在函数组建的当次执行过程中，useEffect内执行的代码不影响渲染出来的UI。\n\n\n**useEffect是每次组件render完后判断以来并执行。**\n\n\n```javascript\nuseEffect(callback, dependencies);\n```\n\n\n如果不指定依赖项那么callback在每次函数组件执行完后都会执行，如果指定那么只有依赖项中的值发生改变才会执行。\n\n\n```javascript\nimport React, { useState, useEffect } from \"react\";\n\nfunction BlogView({ id }) {\n  // 设置一个本地 state 用于保存 blog 内容\n  const [blogContent, setBlogContent] = useState(null);\n\n  useEffect(() => {\n    // useEffect 的 callback 要避免直接的 async 函数\n    // 需要封装一下\n    const doAsync = async () => {\n      // 当 id 发生变化时，将当前内容清除以保持一致性\n      setBlogContent(null);\n      // 发起请求获取数据\n      const res = await fetch(`/blog-content/${id}`);\n      // 将获取的数据放入 state\n      setBlogContent(await res.text());\n    };\n    doAsync();\n  }, [id]); // 使用 id 作为依赖项，变化时则执行副作用\n\n  // 如果没有 blogContent 则认为是在 loading 状态\n  const isLoading = !blogContent;\n  return <div>{isLoading ? \"Loading...\" : blogContent}</div>;\n}\n```\n\n\n特殊用法：\n\n1. **没有依赖项**：每次render完一定会执行；\n2. **依赖项为空数组**：只在首次渲染执行时触发；\n3. useEffect允许**返回一个函数，用于在组件销毁时做一些清理操作**；\n\n## Hooks的依赖\n\n\n依赖项不是内置Hooks的特殊机制而是一种设计模式，有类似需求的Hooks都可以用这个模式去实现。\n\n\n⚠️ 注意：\n\n1. 依赖项内定义的变量要一定会在回调函数内使用到；\n2. 依赖项一般是一个常量数组；\n3. React是使用浅比较来对比依赖项是否发生变化，所以需要注意数组或者对象类型；\n\n## Hooks的使用规则\n\n\n### 只能在函数组建的顶级作用域内使用\n\n\n> Hooks不能在循环，条件判断或者嵌套函数内执行，而必须是在顶层。同时**Hooks在组件的多次渲染之间，必须按顺序执行。**\n\n- 所有Hook必须要被执行到\n- 必须按顺序执行\n\n### 只能在函数组件或者其他Hooks中使用\n\n\n如何在class组件内通过Hooks实现逻辑重用 → 利用高阶组件的模式，将Hooks封装成高阶组件，从而让类组件使用。\n\n\n♦️ 总结：\n\n- 在`useEffect`的毁掉函数中使用的变量，都必须在依赖项中声明；\n- Hooks不能出现在条件语句或循环内，也不能出现在return之后；\n- Hooks只能在函数组件或自定义Hooks中使用；\n\n→→ React官方提供专门用来检查Hooks是否正确被使用，`eslint-plugin-react-hooks`\n\n\n---\n\n\n问题：\n\n- 如果useEffect用的某些变量没有在依赖向内指定，会发生什么\n"
  },
  {
    "id": "052b00d2-4389-4501-9933-6cb3872e3597",
    "slug": "052b00d24389450",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-2-React-Hooks-052b00d24389450199336cb3872e3597",
    "title": "⚫ React Hooks 精进 2 - React基本概念 & Hooks的理解",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-01-30T10:35:00.000Z",
    "published_at": "2023-01-30T10:35:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n## 在React之前\n\n\n需要调用DOM的API来修改DOM树的结构从而改变UI的展示方式。\n\n\n## React之后\n\n\n需要要在业务状态和UI状态之间建立一个绑定的关系。\n\n\n---\n\n\n## 基本概念\n\n\n### 用组件的方式描述UI\n\n\n在React内所有的UI都是通过**组件**去描述和组织的，React组件是以**树状结构**组织到一起的，通常会有一个根组件：\n\n- 内置组件：映射到HTML节点的组件\n- 自定义组件：自己创建的组件，使用时必须以大写字母开头\n\n### 使用state和props管理状态\n\n- state：保存状态的机制\n- props：父子组件之间传递状态的方式\n\n在函数组件内可以使用`useState`这个Hook来保存状态，内置组件和自定义组件都可以在使用时把接收的属性props作为参数，当这个参数变化时组件也会自动重新渲染。\n\n\n```javascript\nimport React from \"react\";\n\nfunction CountLabel({ count }) {\n\tconst color = count > 10 ? \"red\" : \"blue\";\n\treturn <span style={{ color }}>{count}</span>\n}\n\nexport default function Counter() {\n\tconst [count, setCount] = React.userState(0);\n\t\n\treturn (\n\t\t<div>\n\t\t\t<CountLabel count={count} onClick={() => setCount(count + 1)} />\n\t\t</div>\n\t) \n}\n```\n\n\n### JSX语法的本质\n\n\nJSX并不是新的模版语言而是一个**语法糖**，不用JSX语法的话也可以使用React.createElement来实现。\n\n1. JSX的表达能力等价于JavaScript；\n2. 无需学习；\n\n## 创建应用\n\n\n```shell\nnpm run create-react-app my-app\ncd my-app\nnpm start\n```\n\n\n### 在组件内执行异步请求\n\n\n需要有数据状态，loading状态以及错误处理。\n\n\n> **在React组件中，任何一个state发生变化，整个函数组件都会被完全执行一遍。**\n\n- 为了避免在组件内重复定义很多函数，可以使用useCallback这个Hook来缓存回调函数；\n- 异步请求逻辑的重用可以利用Redux这个全局状态管理框架；\n\n## 一些思考\n\n\n### React最打动人的特性是什么？或者说它的最大优点。\n\n- 灵活的jsx\n- 生态强大，核心简单，写法灵活\n\n## Hooks（>16.8)\n\n\n> 原来的基于class的组件完全可以继续使用。\n\n\n### React组件的本质\n\n\n就是从Model到View的映射，这里的Model对应的是state和props。\n\n\n**数据绑定**：当Model发生改变时，函数会重新执行，并且生成新的DOM树，然后React再将新的DOM树以最优的方式更新到浏览器。\n\n\n为什么会出现Hooks，原来的Class组件有哪些问题？\n\n- React组件之间不会互相继承，所以没有利用到Class的继承特性；\n- UI是由状态驱动的，很少会在外部调用一个类实例，组件的所有方法都是内部调用；\n\n所以这两个Class最重要的特性都未使用到，所以用函数去描述**`State ⇒ View`**这样的映射才是最合适的，但是函数组件有没有State和生命周期，于是就有了Hooks。\n\n\n### Hooks的诞生\n\n\n函数和对象不同，实例对象不能够在多次执行之间保存状态，所以我们需要一个能够把外部的数据绑定到函数的执行机制。\n\n\n这个机制就是**Hooks，Hooks就是把某个目标结果钩到某个可能会变化的数据源或者事件源上，那么当被钩到的数据或者事件发生变化时，产生这个目标结果的代码会重新执行，产生更新后的结果。**\n\n\n对于函数组件，这个结果就是最终的DOM树；对于`useCallback`，`useMemo`这样的雨缓存相关的组件则是在依赖项发生变化时去更新缓存。Hooks的结构：\n\n\n![a6e410883f0975e888ea749be99e35cf.jpg](https://i.hd-r.cn/a6e410883f0975e888ea749be99e35cf.jpg)\n\n\n‼️ Hooks中被钩的对象可以是某个独立的数据源也可以是另一个Hook执行的结果，这样就可以达成**逻辑复用**的效果。\n\n\n### Hooks带来的最大的好处：逻辑复用\n\n\n在之前的React使用中必须借助高阶组件等设计模式来实现逻辑复用，但告诫组件会产生荣誉的组件节点，所有Hooks也大大的**简化了逻辑复用**。\n\n\n比如说实现窗口大小的监听，窗口大小是一个外部数据状态，我们可以通过Hooks的方式对其进行封装，将其变成一个可绑定的数据源，这样代码会更加简洁直观。\n\n\n### Hooks的另一个好处：有助于关注分离\n\n\n能够针对同一个业务逻辑的代码尽可能聚合在一起，在过去的React内需要把同一个业务逻辑的代码分散在组件的不同生命周期内。\n\n\n## 总结\n\n- React的开发思想：从State⇒View的函数式映射；\n- Hooks解决了Class组件存在的代码冗余，难以逻辑复用的问题；\n"
  },
  {
    "id": "6ed49a2a-dc86-4d84-94f3-808ed5e547c2",
    "slug": "6ed49a2adc864d8",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-1-Hooks-6ed49a2adc864d8494f3808ed5e547c2",
    "title": "⚫ React Hooks 精进 1 - 用Hooks的角度去转变开发思路",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-01-30T10:35:00.000Z",
    "published_at": "2023-01-30T10:35:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n## React 两个颠覆性创新点\n\n- 虚拟DOM机制\n- JSX语法\n\n## Hooks出现之前的业务逻辑复用方式\n\n\n在组件内的不同生命周期中做时间监听的绑定和解绑。\n\n\n## 引入Hooks之后\n\n\n只需要通过Hooks的方式进行封装，将其变成一个可绑定的数据源，这样函数组件就具备了状态管理，生命周期管理等能力。\n\n\n## Hooks的学习路径\n\n1. 全局认知：Hooks的功能边界，什么功能要用Hooks去做\n2. 核心概念和原理：应对实际复杂业务问题的关键能力\n3. 实战：把原理和实际业务场景结合起来，掌握Hooks的思考方式\n\n![fa23b9c56bc62fe4a0bbd40777b6a67a.jpg](https://i.hd-r.cn/fa23b9c56bc62fe4a0bbd40777b6a67a.jpg)\n\n\n## 学习内容：\n\n\n### 基础篇：抓住问题本质，提高解决复杂问题的能力\n\n\n### 实战篇：业务场景驱动，掌握解决实际问题的思考能力\n\n\n### 扩展篇：了解工具。生态和未来，开拓技术视野\n\n"
  },
  {
    "id": "c27da161-a208-4893-bddc-8a7447e59698",
    "slug": "c27da161a208489",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6db8f3a0-318c-4fe3-a023-b2ca401fcb80/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075038Z&X-Amz-Expires=3600&X-Amz-Signature=16f0bdd3042bc2b424def25f022ec85761ffd48e4b3e7648e6c6324fb952f8f6&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/001-c27da161a2084893bddc8a7447e59698",
    "title": "汪汪周刊 001期： 新年再出发",
    "format": "lake",
    "description": "新的一年我想重新出发，和大家一起共同成长。",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-01-30T10:35:00.000Z",
    "published_at": "2023-01-30T10:35:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6db8f3a0-318c-4fe3-a023-b2ca401fcb80/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075038Z&X-Amz-Expires=3600&X-Amz-Signature=16f0bdd3042bc2b424def25f022ec85761ffd48e4b3e7648e6c6324fb952f8f6&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![IMG_5974.jpg](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/560bd117-80ad-4b0e-bac7-73a9319fe47e/IMG_5974.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230806%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230806T075040Z&X-Amz-Expires=3600&X-Amz-Signature=6462c4af3c35bb9af279b5c77461b9131d8fbe475476c17393a86884c41f21df&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 蔓越莓曲奇\n\n\n# 前提\n\n\n我以前也有想过做一些平时的学习分享，但是基本都没有坚持下来，再者去年的特殊情况使我的工作学习都进入了一个停滞状态，新的一年我想重新出发，和大家一起共同成长。\n\n\n同时想通过做这个周刊分享来提高自己的文笔和逻辑能力。\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n- 回顾自己的github：[https://wrapped.run/](https://wrapped.run/#)\n\n\t看我去年那少得可怜的commits。\n\n\n\t![0fed55c5a8c4a8d94a40ff6e9e614d39.png](https://i.hd-r.cn/0fed55c5a8c4a8d94a40ff6e9e614d39.png)\n\n- ChatGPT\n\n\t> **ChatGPT: OptimizingLanguage Modelsfor Dialogue**\n\n\n\t\tWe’ve trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer followup questions, admit its mistakes, challenge incorrect premises, and reject inappropriate requests. ChatGPT is a sibling model to [InstructGPT](https://openai.com/blog/instruction-following/), which is trained to follow an instruction in a prompt and provide a detailed response.\n\n\n\tChatGPT是一款基于GPT-3模型的聊天机器人平台，它拥有智能的自然语言处理功能，能够帮助开发者快速构建出自定义的聊天机器人，并且支持多种语言的交互，可以帮助开发者更快地将技术成果推向市场。\n\n\t- 但是目前ChatGPT被部分地区和学校禁用。\n- 双缝干涉实验\n\n\t因为我不是专业的怕形容不好，但是可以看一下相关的视频或者解说，非常有意思。\n\n\n# 工具\n\n- 最近觉得不错的免费图床：[https://www.hd-r.cn/](https://www.hd-r.cn/)，不会很大程度地压缩图片，速度快，无需注册\n- 快速生成自定义的Notion封面：[https://notioncovergenerator.com/](https://notioncovergenerator.com/)，Create CustomNotion Coversfree in minutes!\n\n\t![1ea04e31af95dc545128439559ac21a2.png](https://i.hd-r.cn/1ea04e31af95dc545128439559ac21a2.png)\n\n- [**Splitbee**](https://splitbee.io/)，轻量级访客分析工具，我的组件库也是用了这个工具，可以充分了解大家更喜欢哪个组件便于我去更新迭代更多大家喜爱的内容。\n\n\t![3c8eff422fa2e74af5045b0250a70440.png](https://i.hd-r.cn/3c8eff422fa2e74af5045b0250a70440.png)\n\n\n# 专业技术领域\n\n- [**Best Way to Handle Form Validation: React Hook Form and Zod**](https://blog.bitsrc.io/react-form-validation-5aa06193bec4) **`英文`**\n- [**You’ve Got Options for Removing Event Listeners**](https://www.macarthur.me/posts/options-for-removing-event-listeners) **`英文`**\n- 模块联邦作者 Zack Jackson 近几周在投入 [Rust Webpack](https://twitter.com/ScriptedAlchemy/status/1619951813687660544) ，30 天内会[开源](https://twitter.com/ScriptedAlchemy/status/1621220073192189952)。\n\t- 在工作项目内也使用了模块联邦，还需要再多看看源码。\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 本周比较忙碌所以暂无更新。\n\n# 最后的碎碎念\n\n- 每次回家都要玩烘焙，买一堆烘焙材料，结果每次都要在返杭前疯狂的消耗材料不然就得浪费。\n- 这周正式回杭州啦，从去年开始已经居家办公7个月了，现在特别想正式回归职场。\n- 说好的年后开始减肥却每天还在大吃大喝，住院的护士问我是不是胖了让我控制体重，害，减肥太难了。\n\n# 话题\n\n\n你相信有平行世界吗？\n\n\n如果有你觉得平行世界的你是个怎么样的人？\n\n\n![9f144b95fa5e7e2b4105f7bbd6a511e4.jpg](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "c27da161-a208-4893-bddc-8a7447e59698",
    "slug": "c27da161a208489",
    "icon": {
      "type": "emoji",
      "emoji": "💟"
    },
    "cover": "https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/6db8f3a0-318c-4fe3-a023-b2ca401fcb80/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060039Z&X-Amz-Expires=3600&X-Amz-Signature=b418e5c158d3e4f895504d62ed6eb68601e165231c560df2382563acadaa1232&X-Amz-SignedHeaders=host&x-id=GetObject",
    "url": "https://www.notion.so/001-c27da161a2084893bddc8a7447e59698",
    "title": "💟 汪汪周刊 001期： 新年再出发",
    "format": "lake",
    "description": "新的一年我想重新出发，和大家一起共同成长。",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-01-30T10:35:00.000Z",
    "published_at": "2023-01-30T10:35:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [每周分享]<br />categories: [周刊]<br />cover: https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/6db8f3a0-318c-4fe3-a023-b2ca401fcb80/%E8%93%9D%E7%B2%89%E8%89%B2%E8%B7%B3%E8%9A%A4%E5%B8%82%E5%9C%BA%E7%9F%A2%E9%87%8F%E6%B4%BB%E5%8A%A8%E5%AE%A3%E4%BC%A0%E4%B8%AD%E6%96%87%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%B0%81%E9%9D%A2.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060039Z&X-Amz-Expires=3600&X-Amz-Signature=b418e5c158d3e4f895504d62ed6eb68601e165231c560df2382563acadaa1232&X-Amz-SignedHeaders=host&x-id=GetObject\n\n---\n\n\n![](https://prod-files-secure.s3.us-west-2.amazonaws.com/a0bdc100-d0e6-4660-8a91-9071d9d01779/560bd117-80ad-4b0e-bac7-73a9319fe47e/IMG_5974.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45HZZMZUHI%2F20240105%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20240105T060040Z&X-Amz-Expires=3600&X-Amz-Signature=0695bc795aa4ad78ace15787dffc3444c58f621ee1dc431030e8793643dbdbd1&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n### Hello，大家好，这里是阿汪同学。\n\n\n### 本期关键词： 蔓越莓曲奇\n\n\n# 前提\n\n\n我以前也有想过做一些平时的学习分享，但是基本都没有坚持下来，再者去年的特殊情况使我的工作学习都进入了一个停滞状态，新的一年我想重新出发，和大家一起共同成长。\n\n\n同时想通过做这个周刊分享来提高自己的文笔和逻辑能力。\n\n\n‼️ **本周刊非纯技术周刊，包括各方面的分享**。\n\n\n# 有趣的\n\n- 回顾自己的github：[https://wrapped.run/](https://wrapped.run/#)\n\n\t看我去年那少得可怜的commits。\n\n\n\t![](https://i.hd-r.cn/0fed55c5a8c4a8d94a40ff6e9e614d39.png)\n\n- ChatGPT\n\n\t> **ChatGPT: OptimizingLanguage Modelsfor Dialogue**\n\n\n\t\tWe’ve trained a model called ChatGPT which interacts in a conversational way. The dialogue format makes it possible for ChatGPT to answer followup questions, admit its mistakes, challenge incorrect premises, and reject inappropriate requests. ChatGPT is a sibling model to [InstructGPT](https://openai.com/blog/instruction-following/), which is trained to follow an instruction in a prompt and provide a detailed response.\n\n\n\tChatGPT是一款基于GPT-3模型的聊天机器人平台，它拥有智能的自然语言处理功能，能够帮助开发者快速构建出自定义的聊天机器人，并且支持多种语言的交互，可以帮助开发者更快地将技术成果推向市场。\n\n\t- 但是目前ChatGPT被部分地区和学校禁用。\n- 双缝干涉实验\n\n\t因为我不是专业的怕形容不好，但是可以看一下相关的视频或者解说，非常有意思。\n\n\n# 工具\n\n- 最近觉得不错的免费图床：[https://www.hd-r.cn/](https://www.hd-r.cn/)，不会很大程度地压缩图片，速度快，无需注册\n- 快速生成自定义的Notion封面：[https://notioncovergenerator.com/](https://notioncovergenerator.com/)，Create CustomNotion Coversfree in minutes!\n\n\t![](https://i.hd-r.cn/1ea04e31af95dc545128439559ac21a2.png)\n\n- [**Splitbee**](https://splitbee.io/)，轻量级访客分析工具，我的组件库也是用了这个工具，可以充分了解大家更喜欢哪个组件便于我去更新迭代更多大家喜爱的内容。\n\n\t![](https://i.hd-r.cn/3c8eff422fa2e74af5045b0250a70440.png)\n\n\n# 专业技术领域\n\n- [**Best Way to Handle Form Validation: React Hook Form and Zod**](https://blog.bitsrc.io/react-form-validation-5aa06193bec4) **`英文`**\n- [**You’ve Got Options for Removing Event Listeners**](https://www.macarthur.me/posts/options-for-removing-event-listeners) **`英文`**\n- 模块联邦作者 Zack Jackson 近几周在投入 [Rust Webpack](https://twitter.com/ScriptedAlchemy/status/1619951813687660544) ，30 天内会[开源](https://twitter.com/ScriptedAlchemy/status/1621220073192189952)。\n\t- 在工作项目内也使用了模块联邦，还需要再多看看源码。\n\n# Widverse · 汪汪汪世界\n\n\n> Widverse 是我开发的组件库，支持嵌入Notion，FlowUs，Wolai，github等。\n\n- 本周比较忙碌所以暂无更新。\n\n# 最后的碎碎念\n\n- 每次回家都要玩烘焙，买一堆烘焙材料，结果每次都要在返杭前疯狂的消耗材料不然就得浪费。\n- 这周正式回杭州啦，从去年开始已经居家办公7个月了，现在特别想正式回归职场。\n- 说好的年后开始减肥却每天还在大吃大喝，住院的护士问我是不是胖了让我控制体重，害，减肥太难了。\n\n# 话题\n\n\n你相信有平行世界吗？\n\n\n如果有你觉得平行世界的你是个怎么样的人？\n\n\n![](https://i.hd-r.cn/9f144b95fa5e7e2b4105f7bbd6a511e4.jpg)\n\n"
  },
  {
    "id": "ce50450a-16b2-4f24-9dd2-316d85a0d909",
    "slug": "ce50450a16b24f2",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/2022-ce50450a16b24f249dd2316d85a0d909",
    "title": "⚫ 心之所向，行之所往 ｜ 2022总结",
    "format": "lake",
    "description": "跌宕起伏，兵荒马乱的一年。",
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-01-30T10:35:00.000Z",
    "published_at": "2023-01-30T10:35:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [复盘]<br />categories: [随笔]<br />cover: null\n\n---\n\n\n说实话，这一年大概是跌宕起伏，兵荒马乱的一年吧。\n\n\n### 工作 & 学习\n\n\n> 🟡 **换了新工作……**  \n> 年初的时候公司的状况实在是有点不好，然后因为一直都跨不出舒适圈，教练非常热心地想要给我介绍工作，刚好她的有个学员的朋友有内推机会，于是想要我发简历，难受，甚至简历都需呀别人催好几遍。  \n>   \n> 发完简历之后，对方表示还不错，我真的是又忐忑又开心，因为我知道其实我不算优秀。之后我提前请假回家过年，正好在回家之后几天收到了面试邀约，不过线上的面试让我减轻了一些压力，第一个面试是关于一些基础问题的面试，还做了一个css效果的小demo，我感觉这个我还是表现得不错。再然后隔天又收到了第二场面试的邀约，这次是一个在线实时coding的测试，关于搜索匹配，其实面试过程不算顺利，也可能是因为在线coding让我特别紧张，之后在面试官的提示下也算是完成了他的预期效果（不过是在面试结束后做好的）。  \n>   \n> 所以我还是算顺利地收到了offer，真的是意外地顺利。\n\n\n\t年初的时候公司的状况实在是有点不好，然后因为一直都跨不出舒适圈，教练非常热心地想要给我介绍工作，刚好她的有个学员的朋友有内推机会，于是想要我发简历，难受，甚至简历都需呀别人催好几遍。\n\n\n\t发完简历之后，对方表示还不错，我真的是又忐忑又开心，因为我知道其实我不算优秀。之后我提前请假回家过年，正好在回家之后几天收到了面试邀约，不过线上的面试让我减轻了一些压力，第一个面试是关于一些基础问题的面试，还做了一个css效果的小demo，我感觉这个我还是表现得不错。再然后隔天又收到了第二场面试的邀约，这次是一个在线实时coding的测试，关于搜索匹配，其实面试过程不算顺利，也可能是因为在线coding让我特别紧张，之后在面试官的提示下也算是完成了他的预期效果（不过是在面试结束后做好的）。\n\n\n\t所以我还是算顺利地收到了offer，真的是意外地顺利。\n\n\n> 🟡 **学习基本搁置……**\n\n\n### 爱好\n\n\n今年最没想到的大概是在自媒体上的发展吧，因为身体原因中间搁置了很久，在身体状况好些的时候重新开始了原来的分享，渐渐地也收到了一些合作，然后发布了一个小模版没想到也小爆了一下，希望之后能有更多更好的想法。\n\n\n希望今年的小红书粉丝能达到2w。\n\n\n### 2023的展望\n\n- 希望在专业技能上能有所长进，能多写技术博客\n- 身体健康，开开心心\n- 保持学习\n\n### 今年事件回顾\n\n\n> 🟡 一月  \n> - 达成了蹬腿131kg的成就。  \n>   \n> - 刚买的鼠标放在被子上的缘故，第二天出现在了洗衣机里，不过很坚强地并没有受伤。  \n>   \n> - 妹妹去上班穿了我前一天穿过的衣服，所以带走了我兜里的钥匙，于是被锁在了家里，并且我是在马上要出门去上课的时候才发现，和教练调节了迟一小时上课，并叫了跑腿，外面大雨滂沱，内心迷茫无措。  \n>   \n> - 回家乔迁啦。  \n>   \n> - 在线面试，拿到offer。\n\n\t- 达成了蹬腿131kg的成就。\n\t- 刚买的鼠标放在被子上的缘故，第二天出现在了洗衣机里，不过很坚强地并没有受伤。\n\t- 妹妹去上班穿了我前一天穿过的衣服，所以带走了我兜里的钥匙，于是被锁在了家里，并且我是在马上要出门去上课的时候才发现，和教练调节了迟一小时上课，并叫了跑腿，外面大雨滂沱，内心迷茫无措。\n\t- 回家乔迁啦。\n\t- 在线面试，拿到offer。\n\n> 🟡 二月  \n> - 在家看冬奥会。  \n>   \n> - 02/21入职新公司，结果一屁股坐在了地上。\n\n\t- 在家看冬奥会。\n\t- 02/21入职新公司，结果一屁股坐在了地上。\n\n> 🟡 三月  \n> - 之前的公司忘记给我停缴，结果还想让我交公司交的部分，最后协调只交了自己交的部分。  \n>   \n> - 第一次做美甲。  \n>   \n> - 硬拉上了新高度70kg。  \n>   \n> - gitee图床被🈲️了  \n>   \n> - 一个月喝了好多奶茶咖啡\n\n\t- 之前的公司忘记给我停缴，结果还想让我交公司交的部分，最后协调只交了自己交的部分。\n\t- 第一次做美甲。\n\t- 硬拉上了新高度70kg。\n\t- gitee图床被🈲️了\n\t- 一个月喝了好多奶茶咖啡\n\n> 🟡 四月  \n> - 非正式会谈官宣。  \n>   \n> - 开始常态化核酸检测。  \n>   \n> - 收到了教练送的体脂秤。  \n>   \n> - 花28元做了一次单采。  \n>   \n> - 开始居家办公（但是谁知道才办了一天就……  \n>   \n> - 和妹妹一起去了植物园，第一次贴了假睫毛。  \n>   \n> - 因为疫情取消了我们的五一之旅。\n\n\t- 非正式会谈官宣。\n\t- 开始常态化核酸检测。\n\t- 收到了教练送的体脂秤。\n\t- 花28元做了一次单采。\n\t- 开始居家办公（但是谁知道才办了一天就……\n\t- 和妹妹一起去了植物园，第一次贴了假睫毛。\n\t- 因为疫情取消了我们的五一之旅。\n\n> 🟡 五月  \n> - 之前在身上摸到了一个肿块，趁五一去检查，结果不太好，需要手术确认。  \n>   \n> - 做了局麻手术，术中病理做出来是恶性肿瘤。  \n>   \n> - 请假。  \n>   \n> - 去做了生殖保护咨询。\n\n\t- 之前在身上摸到了一个肿块，趁五一去检查，结果不太好，需要手术确认。\n\t- 做了局麻手术，术中病理做出来是恶性肿瘤。\n\t- 请假。\n\t- 去做了生殖保护咨询。\n\n> 🟡 六月  \n> - 回家修养，开始化疗之程。  \n>   \n> - 手术切口一直好不了。  \n>   \n> - 剃了光头。\n\n\t- 回家修养，开始化疗之程。\n\t- 手术切口一直好不了。\n\t- 剃了光头。\n\n> 🟡 七月  \n> - 第一次吃了甲鱼。  \n>   \n> - 回归工作，居家办公中。  \n>   \n> - 生日呀。  \n>   \n> - 抢到了饿了么免单。\n\n\t- 第一次吃了甲鱼。\n\t- 回归工作，居家办公中。\n\t- 生日呀。\n\t- 抢到了饿了么免单。\n\n> 🟡 八月  \n> - 收到了生病之后的第一笔工资。  \n>   \n> - 接到了小红书长期合作（也是第一笔合作。\n\n\t- 收到了生病之后的第一笔工资。\n\t- 接到了小红书长期合作（也是第一笔合作。\n\n> 🟡 九月  \n> - 小红书5000粉。  \n>   \n> - 吃青蟹的时候被扎了，没想到手指就此发炎，然后因为白细胞太低去了医院急诊，结果发现发烧了，于是又去发热门诊验血打针。  \n>   \n> - 每天去医院输液。\n\n\t- 小红书5000粉。\n\t- 吃青蟹的时候被扎了，没想到手指就此发炎，然后因为白细胞太低去了医院急诊，结果发现发烧了，于是又去发热门诊验血打针。\n\t- 每天去医院输液。\n\n> 🟡 十月  \n> - 买了一个大菠萝蜜。  \n>   \n> - 每天去医院输液。  \n>   \n> - 公众号粉丝5000。\n\n\t- 买了一个大菠萝蜜。\n\t- 每天去医院输液。\n\t- 公众号粉丝5000。\n\n> 🟡 十一月  \n> - 结膜炎，化疗住院。  \n>   \n> - 因为来医院的时候和阳性时空伴随了，在医院被隔离了5天。  \n>   \n> - 结束化疗。  \n>   \n> - 小红书粉丝10000。\n\n\t- 结膜炎，化疗住院。\n\t- 因为来医院的时候和阳性时空伴随了，在医院被隔离了5天。\n\t- 结束化疗。\n\t- 小红书粉丝10000。\n\n> 🟡 十二月  \n> - 开始放疗。  \n>   \n> - B站粉丝20000。  \n>   \n> - 更新了组件库2.0。\n\n\t- 开始放疗。\n\t- B站粉丝20000。\n\t- 更新了组件库2.0。\n\n---\n\n\n愿一直做一个善良的人。\n\n\n愿年年身体健康，万事如意。\n\n\n愿新的一年心之所向，行之所往。\n\n"
  },
  {
    "id": "d5fc6184-d9cf-4478-bc67-54b8c42dc17c",
    "slug": "d5fc6184d9cf447",
    "icon": {
      "type": "emoji",
      "emoji": "💤"
    },
    "cover": null,
    "url": "https://www.notion.so/Notion-Notion-API-Notion-Hexo-d5fc6184d9cf4478bc6754b8c42dc17c",
    "title": "💤 「Notion」利用Notion API将Notion文章整合到本地Hexo项目（一）",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-05T09:03:00.000Z",
    "created_at": "2023-01-30T10:35:00.000Z",
    "published_at": "2023-01-30T10:35:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [Notion]<br />categories: [Notion-API]<br />cover: null\n\n---\n\n\n因为我的Hexo博客是拉取我在语雀上的文章还有本地写的文章，所以没有直接采用相关的Notion部署成Blog的已有API。\n\n\n还是使用将文章拉取到本地再手动部署的方式。\n\n\n> 参考：[yuque-hexo](https://github.com/x-cold/yuque-hexo)\n\n\n## **为Notion API设置访问令牌**\n\n\n需要设置一个Integration（集成），通过Notion API连接访问自己的数据库，然后生成一个访问令牌来访问Notion的API。\n\n\n在[Notion API文档](https://developers.notion.com/reference/intro)页面，点击右上角的**View my integrations** 链接。点击**+ New integration**按钮。\n\n\n![2022-09-10-20-16-22.png](https://i.postimg.cc/xd0zGHgm/2022-09-10-20-16-22.png)\n\n\n创建集成完毕后，将会在详情页看到自己的访问令牌：\n\n\n![2022-09-10-20-17-28.png](https://i.postimg.cc/BQ7h8Sg4/2022-09-10-20-17-28.png)\n\n\n## 在Notion内创建你的博客表格\n\n\n![2022-09-10-20-20-05.png](https://i.postimg.cc/zX4CZV7b/2022-09-10-20-20-05.png)\n\n\n我创建了一个Blog表格，并为每个文章设置了`title`，`slug(urlname)`，`tags`，`categories`，`description`，`publish`，`created_at`和`updated_at`这几个字断。\n\n\n其中`slug`是直接截取了id的一部分作为url name：\n\n\n![2022-09-10-20-23-53.png](https://i.postimg.cc/HxW545YK/2022-09-10-20-23-53.png)\n\n\n## 在blog项目内配置相关信息\n\n\n点击Blog页面右上角的**···**按钮，在`Connections`内选择我们刚刚创建的**my-blog**集成。\n\n\n事先拥有一个 [hexo](https://github.com/hexojs/hexo)项目，并在 `package.json`中配置相关信息：\n\n\n```json\n\"notionConfig\": {\n    \"mdNameFormat\": \"slug\",\n    \"baseUrl\": \"https://api.notion.com/v1/databases/\",\n    \"token\": \"your Internal Integration Token\",\n    \"database\": \"your database id\",\n    \"postPath\": \"source/_posts/notion\" // markdown所在文件\n},\n```\n\n\n太久了，快要忘记内容了，等下次重新看下再继续。\n\n"
  },
  {
    "id": "cd925242-43e3-4316-ad82-87c753f6ce2b",
    "slug": "cd92524243e3431",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-13-Hooks-Form-cd92524243e34316ad8287c753f6ce2b",
    "title": "React Hooks 精进 13 - Hooks给Form带来的新变化",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-06T07:51:00.000Z",
    "created_at": "2023-08-06T07:20:00.000Z",
    "published_at": "2023-08-06T07:20:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 在表单中使用React组件：受控组件和非受控组件\n\n\n非受控组件：表单元素的值不是由副组件决定的，是完全内部的状态\n\n\n通过非受控组件的方式，可以避免某些程度上的组件重复渲染导致的性能问题，但是无法对外有交互。\n\n\n# 使用Hooks简化表单处理\n\n\n维护表单组件的状态逻辑，核心在于：**字段名，value值，onChange事件**。\n\n\n这就是很多组件库里的useForm这个功能，可以通过提供字段名去取值和设值，就不需要繁琐地为每个表单元素设置状态。\n\n\n核心原理：**把表单的状态管理单独提取出来**， 成为一个可重用的Hook。\n\n\n## 处理表单验证\n\n- 如何定义错误状态\n- 如何设置错误状态\n\n可以传递validators对象给useForm这个Hook，然后在hook内在setFieldValue时对其进行验证，并在返回时返回错误信息给调用者。\n\n\n**关键就是在于把表单状态逻辑和UI展示逻辑给予Hooks进行分离。**\n\n\n```typescript\nimport { useState, useMemo, useCallback } from \"react\";\n\nconst useForm = (initialValues = {}, validators) => {\n  const [values, setValues] = useState(initialValues);\n  const [errors, setErrors] = useState({});\n\n  const setFieldValue = useCallback(\n    (name, value) => {\n      setValues((values) => ({\n        ...values,\n        [name]: value,\n      }));\n\n      if (validators[name]) {\n        const errMsg = validators[name](value);\n        setErrors((errors) => ({\n          ...errors,\n          [name]: errMsg || null,\n        }));\n      }\n    },\n    [validators],\n  );\n\n  return { values, errors, setFieldValue };\n};\n\nexport default () => {\n  const validators = useMemo(() => {\n    return {\n      name: (value) => {\n        if (value.length < 2) return \"Name length should be no less than 2.\";\n        return null;\n      },\n      email: (value) => {\n        if (!value.includes(\"@\")) return \"Invalid email address\";\n        return null;\n      },\n    };\n  }, []);\n  const { values, errors, setFieldValue } = useForm({}, validators);\n  const handleSubmit = useCallback(\n    (evt) => {\n      evt.preventDefault();\n      console.log(values);\n    },\n    [values],\n  );\n  return (\n    <form onSubmit={handleSubmit}>\n      <div>\n        <label>Name: </label>\n        <input\n          value={values.name || null}\n          onChange={(evt) => setFieldValue(\"name\", evt.target.value)}\n        />\n        {errors.name && <span style={{ color: \"red\" }}>{errors.name}</span>}\n      </div>\n\n      <div>\n        <label>Email:</label>\n        <input\n          value={values.email || null}\n          onChange={(evt) => setFieldValue(\"email\", evt.target.value)}\n        />\n        {errors.email && <span style={{ color: \"red\" }}>{errors.email}</span>}\n      </div>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n\n# 思考题\n\n1. 如何在自定义的useForm Hook中提供reset的API？\n\n\t就是返回一个置空的函数。\n\n2. 在自定义的useForm内如何实现支持异步验证？\n"
  },
  {
    "id": "77392cbf-81de-473c-908a-44554fc2298c",
    "slug": "77392cbf81de473",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-12-77392cbf81de473c908a44554fc2298c",
    "title": "React Hooks 精进 12 - 项目结构：按领域组织文件夹结构",
    "format": "lake",
    "description": "还需要再思考一下，是一个实际开发思维的转变。",
    "updated_at": "2023-08-06T07:51:00.000Z",
    "created_at": "2023-08-06T06:38:00.000Z",
    "published_at": "2023-08-06T06:38:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n**在实际开发中，关键在于：每增加一个新的功能，整个应用程序的复杂度不应该明显上升，这样才能保证应用程序始终可扩展，可维护。**\n\n\n# 软件复杂度的根源：复杂的依赖关系\n\n\n## 按领域组织文件夹结构\n\n\n通常在开发中会从技术角度对文件夹进行拆分，而不是按照业务功能组织在一起，这样会导致无法直观的知道一个功能的相关代码在哪些文件夹，还有开发一个功能时需要频繁切换源代码目录。\n\n\n我们可以从领域角度出发组织源代码，自身就包含需要的所有技术模块。\n\n\n并且需要尽量扁平化地组织所有代码，而不要按小功能去增加嵌套的文件夹。\n\n\n## 处理模块间的依赖：模块间的交互\n\n\n**把依赖从技术层面提升到业务层面。**\n\n- 硬依赖：功能A地实现必须基于功能B\n- 软依赖：功能B扩展了功能A\n\n开发需要达到的目标是：**删除一个功能像删除一个文件夹那么简单**，这才是真正的松耦合的系统。\n\n\n所以需要做的就是让模块之间的交互不在通过硬依赖。\n\n\n### 扩展点机制：在任何可能产生单点复杂度的模块中，通过扩展点的方式允许其他模块为其增加功能。\n\n\n[http://github.com/rekit/js-plugin](http://github.com/rekit/js-plugin)\n\n\n利用类似事件的订阅和发布模型去建立这样一个机制。\n\n\n# 思考题\n\n\n如果使用了Redux，如何在采用按领域组织时让业务功能的Redux在各自的文件夹下呢？\n\n"
  },
  {
    "id": "8f2c2dc3-4623-4e54-af5c-b3d5bf1b8626",
    "slug": "8f2c2dc346234e5",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-14-8f2c2dc346234e54af5cb3d5bf1b8626",
    "title": "React Hooks 精进 14 - 浮动层的使用 & 路由管理",
    "format": "lake",
    "description": "1， 需要在实战中进行操作尝试。 03-15",
    "updated_at": "2023-08-08T13:22:00.000Z",
    "created_at": "2023-08-08T11:53:00.000Z",
    "published_at": "2023-08-08T11:53:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 浮动层的使用\n\n\n通常的对话框使用：\n\n- 对话框需要在父组件中声明，才能在子组件中控制是否显示。\n- 给对话框传递参数智能由props传入，意味着所有状态管理需要在更高级别的组件上。\n\n## 处理对话框的误区\n\n\n当这里是一个左右分栏布局的页面，在左侧的菜单栏由右侧列表的操作按钮，此时左侧组件和右侧组件共享一个对话框，那么此时就需要在layout这个层级上去设置对话框。\n\n\n但是这种处理方式会有以下两个问题：\n\n- 语义隔离不明确：是两个本不相关的功能产生依赖\n- 难以扩展\n\n需要思考的问题就是：**一个实现业务逻辑的Modal究竟应该在哪个组件中去声明？又该如何进行交互？从而使让对话框相关的业务逻辑能够更加模块化**。\n\n\n## 思路：使用全局状态管理所有对话框\n\n\n对话框本质：独立于其他界面的独立功能。\n\n\n所以我们可以给对话框定义一个全局唯一的ID，通过ID去显示/隐藏对话框并为之传递参数。\n\n\n预期的操作方式：\n\n\n```typescript\nconst modal = useNiceModal(\"user-info-modal\");\nmodal.show(args)\nmodal.hide()\n```\n\n\n## 实现：创建组件和相关API\n\n\n### 首先是全局状态的管理（以Redux为例）\n\n\n创建一个可以处理所有对话框状态的reducer。\n\n\n```typescript\nconst modalReducer = (state = { hiding: {} }, action) => {\n  switch (action.type) {\n    case \"nice-modal/show\":\n      return {\n        ...state,\n        [action.payload.modalId]: action.payload.args || true,\n        hiding: {\n          ...state.hiding,\n          [action.payload.modalId]: false,\n        },\n      };\n    case \"nice-modal/hide\":\n      return action.payload.force\n        ? {\n            ...state,\n            [action.payload.modalId]: false,\n            hiding: { [action.payload.modalId]: false },\n          }\n        : { ...state, hiding: { [action.payload.modalId]: true } };\n    default:\n      return state;\n  }\n};\n```\n\n\n```typescript\n// action creators\nfunction showModal(modalId, args) {\n  return {\n    type: \"nice-modal/show\",\n    payload: {\n      modalId,\n      args,\n    },\n  };\n}\n\nfunction hideModal(modalId, force) {\n  return {\n    type: \"nice-modal/hide\",\n    payload: {\n      modalId,\n      force,\n    },\n  };\n}\n```\n\n\n创建一个Hook，保证逻辑重用：\n\n\n```typescript\nconst modalCallbacks = {};\nconst useNiceModal = (modalId) => {\n  const dispatch = useDispatch();\n  const show = useCallback(\n    (args) => {\n      return new Promise((resolve) => {\n        modalCallbacks[modalId] = resolve;\n        dispatch(showModal(modalId, args));\n      });\n    },\n    [dispatch, modalId],\n  );\n  const resolve = useCallback(\n    (args) => {\n      if (modalCallbacks[modalId]) {\n        modalCallbacks[modalId](args);\n        delete modalCallbacks[modalId];\n      }\n    },\n    [modalId],\n  );\n\n  const hide = useCallback(\n    (force) => {\n      dispatch(hideModal(modalId, force));\n      delete modalCallbacks[modalId];\n    },\n    [dispatch, modalId],\n  );\n\n  const args = useSelector((s) => s[modalId]);\n  const hiding = useSelector((s) => s.hiding[modalId]);\n\n  return useMemo(\n    () => ({ args, hiding, visible: !!args, show, hide, resolve }),\n    [args, hide, show, resolve, hiding],\n  );\n};\n\n// 封装一个通用对话框\nfunction NiceModal({ id, children, ...rest }) {\n  const modal = useNiceModal(id);\n  return (\n    <Modal\n      onCancel={() => modal.hide()}\n      onOk={() => modal.hide()}\n      afterClose={() => modal.hide(true)}\n      visible={!modal.hiding}\n      {...rest}\n    >\n      {children}\n    </Modal>\n  );\n}\n```\n\n\n最后可以使用容器模式，在对话框关闭时直接返回null从而以保证性能。\n\n\n```typescript\nexport const createNiceModal = (modalId, Comp) => {\n  return (props) => {\n    const { visible, args } = useNiceModal(modalId);\n    if (!visible) return null;\n    return <Comp {...args} {...props} />;\n  };\n};\n```\n\n\n最后就是调用操作：\n\n\n```typescript\nimport { Button } from \"antd\";\nimport { createStore } from \"redux\";\nimport { Provider } from \"react-redux\";\nimport NiceModal, {\n  createNiceModal,\n  useNiceModal,\n  modalReducer,\n} from \"./NiceModal\";\n\n// redux store\nconst store = createStore(modalReducer);\n\nconst MyModal = createNiceModal(\"my-modal\", () => {\n  return (\n    <NiceModal id=\"my-modal\" title=\"Nice Modal\">\n      Hello NiceModal!\n    </NiceModal>\n  );\n});\n\nfunction MyModalExample() {\n  const modal = useNiceModal(\"my-modal\");\n  return (\n    <>\n      <Button type=\"primary\" onClick={() => modal.show()}>\n        Show Modal\n      </Button>\n      <MyModal />\n    </>\n  );\n}\nexport default () => {\n  return (\n    <Provider store={store}>\n      <h1>Nice Modal</h1>\n      <MyModalExample />\n    </Provider>\n  );\n};\n```\n\n\n### 处理对话框的返回值\n\n- 对话框可能需要返回值给调用者\n\n所以可以利用Promise来完成：\n\n\n```typescript\nconst modal = useNiceModal(\"my-modal\");\nmodal.show(args).then(res => {})\n\n// 在useNiceModal内\nconst show = useCallback(\n    (args) => {\n      return new Promise((resolve) => {\n        modalCallbacks[modalId] = resolve;\n        dispatch(showModal(modalId, args));\n      });\n    },\n    [dispatch, modalId],\n  );\n  const resolve = useCallback(\n    (args) => {\n      if (modalCallbacks[modalId]) {\n        modalCallbacks[modalId](args);\n        delete modalCallbacks[modalId];\n      }\n    },\n    [modalId],\n  );\n```\n\n\n## 思考题\n\n\n如果是基于Context该如何实现NiceModal？\n\n\n# 路由管理\n\n- 路由提供了按页面去组织整个应用程序的能力\n- URL（Uniform Resource Locator），表明URL是用于唯一的定位某个资源的\n\n## 路由的工作原理：实现一个简单的路由机制\n\n\n所谓的页面切换就是一个页面局部内容的组件切换。\n\n- 在服务器渲染的页面，URL的变化都是全部页面内容的切换\n- 前段路由管理中，则一般只是主内容区域的变化\n\n实现路由机制的核心逻辑**：根据URL路径这个状态来决定内容区域显示什么组件**。\n\n\n```typescript\nconst MyRouter = ({ children }) => {\n  const routes = _.keyBy(\n    children.map((c) => c.props),\n    \"path\",\n  );\n  const [hash] = useHash();\n  const Page = routes[hash.replace(\"#\", \"\")]?.component;\n  return Page ? <Page /> : \"Not found.\";\n};\n\nconst Route = () => null;\n```\n\n\n其中空组件Route可以接收路由的具体参数path和component从而以声明式的方式去定义路由。\n\n\n```typescript\n<MyRouter>\n            <Route path=\"page1\" component={Page1} />\n            <Route path=\"page2\" component={Page2} />\n            <Route path=\"page3\" component={Page3} />\n            <Route path=\"page4\" component={Page4} />\n</MyRouter>\n```\n\n\n## 使用React Router\n\n\n实际项目中需要考虑：路由嵌套，URL模式匹配，参数提取等。\n\n\nReact Router不仅支持浏览器还支持React Native以及一些用Web实现的移动App。\n\n\n通常在开发中使用的react-router-dom是支持浏览器的模块。\n\n\n### BrowserRouter\n\n\n表示用标准的URL路径去管理路由。\n\n\n### Link\n\n\n定义一个导航链接，可以无刷新地改变页面URL。\n\n\n### Route\n\n\n定义一条路由规则，可以指定匹配路径和渲染内容。\n\n\n### Switch\n\n\n可以保证只有第一个匹配到的路由才会被渲染。\n\n\n## 使用嵌套路由：实现二级导航\n\n- 能够模糊匹配\n- Route能够嵌套使用\n\n## 在URL中保存页面状态\n\n\n利用React Router的参数功能来定义一条路由。\n\n\n```typescript\n<Route path=\"/tabs/:activeTab\" component={TabsPage} />}\n```\n\n\n## 路由层面实现权限控制\n\n\n利用前端路由的动态性。\n\n\n```typescript\nimport { useState } from \"react\";\nimport { Button } from \"antd\";\nimport { Route, Link } from \"react-router-dom\";\n\nconst Page1 = () => \"Page 1\";\nconst Page2 = () => \"Page 2\";\nconst UnauthedPage = () => (\n  <span style={{ color: \"red\" }}>Unauthorized, please log in first.</span>\n);\nexport default () => {\n  const [loggedIn, setLoggedIn] = useState(false);\n  const routes = loggedIn\n    ? [\n        {\n          path: \"/15/RouterAuth\",\n          component: Page1,\n        },\n        {\n          path: \"/15/RouterAuth/page1\",\n          component: Page1,\n        },\n        {\n          path: \"/15/RouterAuth/page2\",\n          component: Page2,\n        },\n      ]\n    : [{ path: \"/15/RouterAuth\", component: UnauthedPage }];\n\n  return (\n    <div>\n      <h1>Router Auth</h1>\n      <Button\n        type={loggedIn ? \"primary\" : \"\"}\n        onClick={() => setLoggedIn((v) => !v)}\n      >\n        {loggedIn ? \"Log Out\" : \"Log In\"}\n      </Button>\n\n      <div className=\"exp-15-router-auth\">\n        <div className=\"exp-15-sider\">\n          <Link to=\"/15/RouterAuth/page1\">Page 1</Link>\n          <Link to=\"/15/RouterAuth/page2\">Page 2</Link>\n        </div>\n        <div className=\"exp-15-page-container\">\n          {routes.map((r) => (\n            <Route path={r.path} component={r.component} />\n          ))}\n        </div>\n      </div>\n    </div>\n  );\n};\n```\n\n\n## 思考题\n\n\n为什么URL存储状态可以简化页面之间的交互？\n\n\n因为如果子页面需要来自父页面的参数时，通过URL可以更好地定位。\n\n"
  },
  {
    "id": "f5c52bc4-bd8d-4a13-9221-6c990c713413",
    "slug": "f5c52bc4bd8d4a1",
    "icon": {
      "type": "emoji",
      "emoji": "🆕"
    },
    "cover": null,
    "url": "https://www.notion.so/js-DOM-f5c52bc4bd8d4a1392216c990c713413",
    "title": "在js内用文本内容定位DOM元素",
    "format": "lake",
    "description": null,
    "updated_at": "2023-08-09T12:16:00.000Z",
    "created_at": "2023-08-09T07:47:00.000Z",
    "published_at": "2023-08-09T07:47:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [Javascript]<br />categories: [Daily]<br />cover: null\n\n---\n\n\n> 在开发中遇到了一个需求：在url内输入页面上的按钮label就可以触发按钮的点击事件。\n\n\n\t此时就需要用文本内容来定位页面上的DOM元素。\n\n\n## 1. 遍历法\n\n\n遍历页面上所有的相关元素。\n\n\n```typescript\nArray.from(document.querySelectorAll('span'))\n.find(el => el.textContent.includes('文本内容'))\n```\n\n\n## 2. XPATH表达式\n\n\n```typescript\ndocument.evaluate(\"//span[contains(., '文本内容')]\", document, null, XPathResult.ANY_TYPE).iterateNext();\n```\n\n\n## 3. jQuery\n\n\n```typescript\nvar $span = $(\"span:contains('文本内容')\"); // 获取的是jQuery对象\nvar span = $span.get(0); // 转换为 js 对象\n```\n\n"
  },
  {
    "id": "d87352fa-777e-4ee6-b467-9529cc8ca26a",
    "slug": "d87352fa777e4ee",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-16-d87352fa777e4ee6b4679529cc8ca26a",
    "title": "React Hooks 精进 16 - 打包部署",
    "format": "lake",
    "description": "这是之后的学习方向：了解Webpack",
    "updated_at": "2023-08-09T13:46:00.000Z",
    "created_at": "2023-08-09T13:11:00.000Z",
    "published_at": "2023-08-09T13:11:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 了解Webpack\n\n\n通常在实际开发中我们不需要太关注源代码是通过什么编译器如何打包成最后的应用程序的，因为IDE已经帮我们把这些都做好了。\n\n\n但是我们需要知道它的主要功能，以及能够排查问题。\n\n- Failed to compile：编译阶段的错误\n- SyntaxError：语法错误\n\n# Webpack的基本工作原理\n\n\n它的核心思路就是将源代码以及图片，样式文件等资源文件都视为模块，然后通过提供对不同类型资源的处理器，将它们进行统一处理，形成最后可在浏览器运行的代码。\n\n\nWebpack的配置主要分成这几个部分：\n\n- 输入输出配置\n- 配置对于每一类资源的处理器\n- 插件配置\n\n# loader和plugin\n\n\n比如我们想在项目中使用Less作为Css的预处理器，需要在Webpack中进行配置。\n\n- less-loader：将less代码转换成css\n- css-loader：用于处理css中的import，url等语句，分析图片等静态资源\n- style-loader：自动生成代码，并将打包后的css插入页面的style标签。\n\n这个过程设计到loader的一个重要机制：**链式使用**。前面一个loader的输出结果可以作为后一个loader的输入。\n\n\n最终生成的css代码会以字符串的形式作为一个模块打包到最终结果，然后在运行时由style-loader提供一个函数injectStyleIntoStyleTag，将这个模块加入到页面的style标签内。\n\n\n如果希望最终生成的css文件和JavaScript文件分开，此时就需要使用到plugin。\n\n\n只需要简单地引入mini-css-extract-plugin，可以识别所有的CSS模块。\n\n\n所以：\n\n- loader：用于处理不同类型的资源，将它们转换成模块\n- plugin：通常用于生成一些除了js bundle之外的打包结果。\n\n# 思考题\n\n\n代码的混淆和压缩应该用loader还是plugin？\n\n\nloader是针对不同类型文件间的转换、关系处理，最终生成js模块，而plugin是针对某一个文件在打包过程中的处理，所以应该使用plugin。\n\n"
  },
  {
    "id": "e3767b97-b5ac-41c3-a83d-ec0c63889798",
    "slug": "e3767b97b5ac41c",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-15-e3767b97b5ac41c3a83dec0c63889798",
    "title": "React Hooks 精进 15 - 按需加载",
    "format": "lake",
    "description": "这期都是我没怎么了解过的内容",
    "updated_at": "2023-08-09T13:10:00.000Z",
    "created_at": "2023-08-09T12:30:00.000Z",
    "published_at": "2023-08-09T12:30:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n> 控制整个应用的大小，提高加载性能是前端开发需要的挑战。\n\n\n提高首屏加载速度：\n\n- 对应用分包\n- 采用高效的缓存策略\n\n# 实现按需加载\n\n\n## 使用import语句，定义按需加载的起始模块\n\n\n本质在于，需要有动态加载模块的能力——import（ECMA Script标准的一个提案）。\n\n\n这里的import作为一个函数动态运行，会返回一个Promise，在模块加载成功后可以在Promise的then回调函数中去使用这个模块。\n\n\n```typescript\nfunction Page() {\n\tconst [RealPage, setRealPage] = useState(null)\n\timport('./RealPage').then(comp => {\n\t\tsetRealPage(comp);\n\t})\n\tif(!RealPage) return 'Loading...'\n\t\n\treturn <RealPage />\n}\n```\n\n\n**import语句完全由Webpack进行处理的。**Webpack会把./RealPage'这个模块为起点的所有依赖模块单独打成一个包。\n\n\n策略：**按业务模块为目标去做隔离，精良在每个模块的起始页去定义这个拆分点。**\n\n\n## 使用react-loadble实现组件的异步加载\n\n\n```typescript\nimport Loadable from \"react-loadable\";\n\nexport default Loadable({\n  loader: () => import(\"./HelloLazyLoad\"),\n  loading({ error }) {\n    return error ? \"Failed\" : \"Loading\";\n  },\n});\n```\n\n- loader：用于传入一个加载器回调，在组件渲染到页面时被执行\n- loading：用于显示加载状态的组件\n\n# 使用service worker缓存前端资源\n\n\n对于加载性能的优化除了按需加载之外，还有就是前端资源的缓存。合理的缓存策略可以保证同样的前端资源永远只下载一次。\n\n\nservice worker通常用于开发离线的web应用。它还提供了拦截前端请求的能力使得它可以结合localStoage成为一个独立的缓存方案（可以看作一种前端的资源请求代理）。\n\n\nservice worker加上cache storage（存储静态资源在浏览器端）具有更高的准确性和可靠性。\n\n- 缓存永远不过期\n- 永远不会访问过期的资源\n\n## 注册Service Worker\n\n\n```typescript\nif('serviceWorker' in navigator) {\n\tnavigator.serviceWorker.register('sw.js').then(() => {\n\t\tconsole.log('registered.')\n\t})\n}\n```\n\n\n其中sw.js就是Service Worker脚本的代码路径。\n\n\n## 在Service Worker安装后初始化缓存机制\n\n\n在Service Worker的实现代码被下载和执行后，就会触发安装完成的事件，可以在sw.js内监听这个事件，从而初始化自己的缓存机制。\n\n\n```typescript\n// 在sw.js中监听安装完成事件\nself.addeventListener('install', e => {\n\tconst cachePromise = caches.open('app_cache')\ne.waitUntil(cachePromise)\n})\n```\n\n\n**Cache Storage是浏览器提供的一种缓存机制。**\n\n\n## 拦截请求\n\n\n可以通过监听fetch事件来处理所有的请求。\n\n\n```typescript\nself.addeventListener('fetch', e => {})\n```\n\n\n# 思考题\n\n\n除了按需加载和Service Worker，还想到哪些提升应用加载性能的方法？\n\n"
  },
  {
    "id": "17368c14-3e82-4ed8-aa72-ab854c827a20",
    "slug": "17368c143e824ed",
    "icon": {
      "type": "emoji",
      "emoji": "⚫"
    },
    "cover": null,
    "url": "https://www.notion.so/React-Hooks-17-17368c143e824ed8aa72ab854c827a20",
    "title": "React Hooks 精进 17 - 单元测试 & 常用的第三方工具库",
    "format": "lake",
    "description": "04-18",
    "updated_at": "2023-08-12T06:24:00.000Z",
    "created_at": "2023-08-12T05:02:00.000Z",
    "published_at": "2023-08-12T05:02:00.000Z",
    "last_editor": "httishere",
    "body": "tags: [React]<br />categories: [React]<br />cover: null\n\n---\n\n\n# 单元测试\n\n\n## 使用Jest和React Testing Library进行单元测试\n\n\n### Jest\n\n\nFacebook推出的js但愿测试框架，零配置就能提供并发测试，测试覆盖率，Mock工具，断言API等。\n\n- Jest从哪里寻找测试文件\n- 如何创建一个测试用例，并用断言验证测试结果\n- 如何运行测试\n\n比如在src下有一个add.js的文件：\n\n\n```typescript\nexport default (a, b) => a + b;\n```\n\n\n再在src目录下创建一个`add.test.js`文件，Jest会寻找src目录下以`.test.js(ts, jsx, tsx)`结尾的文件，以及tests文件夹内的文件，并将其作为测试文件。\n\n\n```typescript\n// add.test.js\n\nimport add from './add';\n\n// 使用test函数创建一个测试用例\ntest('renders learn react link', () => {\n\tconst s = add(1, 2)\n\t// Jest提供的expect函数断言结果等于3\n\texpect(s).toBe(3)\n})\n```\n\n\n**创建完测试用例之后可以在项目根目录通过命令****`npx jest —coverage`****来运行测试。**\n\n\n但是这仅仅是纯js的逻辑测试，对于React应用需要浏览器环境的组件需要引入Test Library了。\n\n\n### React Testing Library\n\n1. **需要有一个浏览器运行环境：**主要通过jsdom这样一个npm模块去实现，可以在nodejs环境中提供一个虚拟的浏览器环境。\n2. **需要能够解析JSX**\n3. **需要能够方便地渲染一个React组件，并对结果进行验证**\n\n项目中自带的App.test.js：\n\n\n```typescript\nimport {render, screen } from ‘@testing-library/react’\n\nimport App from './App'\n\ntest('renders learn react link', () => {\n\trender(<App />)\n\n\tconst linkele = screen.getByText(/learn react/i)\n\texpect(linkele).toBeTheDocument();\n})\n```\n\n\n三个React相关的测试API：\n\n- render：用于在内存中render一个React组件\n- screen：提供工具方法用于获取视频上的元素\n- expect扩展：以方便对UI元素进行断言判断\n\n## 对自定义Hooks进行单元测试\n\n\n**Hooks只能在函数组件或者自定义Hooks中调用**，所以要对Hooks进行单元测试，还是需要借助函数组件。\n\n\n```typescript\n// 对计数器useCounter进行测试\n\nimport {render, screen, fireEvent } from ‘@testing-library/react’\n\ntest('useCounter', () => {\n\tconst testComponent = () => {\n\t\tconst { count, increment, decrement } = useCounter();\n\n\t\treturn (\n\t\t\t<>\n\t\t\t\t<button id=\"btn-dec\" onClick={decrement} />\n\t\t\t\t<span id=\"result\">{count}</span>\n\t\t\t\t<button id=\"btn-inc\" onClick={increment} />\n\t\t\t</>\n\t\t)\n\t}\n\trender(<testComponent />)\n\n\tconst btnDec = document.querySelector('#btn-dec')\n\tconst result = document.querySelector('#result')\n\n\tfireEvent.click(btnDec)\n\texpect(result).toHaveTextContent('-1')\t\n})\n```\n\n\n如何更直接操锁Hooks的API呢，可以将Hook的返回值暴露道函数组件外：\n\n\n```typescript\n// 对计数器useCounter进行测试\n\nimport {render, screen, fireEvent } from ‘@testing-library/react’\n\ntest('useCounter', () => {\n\tconst hookResult = {}\n\tconst testComponent = () => {\n\t\tObjext.assign(hookResult, useCounter());\n\n\t\treturn null\n\t}\n\trender(<testComponent />)\n\n\tact(() => {\n\t\thookResult.increment()\n\t})\n\texpect(hookResult.count).toBe(1)\t\n})\n```\n\n\nTestinfg Library也提供了Hooks测试包：`@testing-library/react-hooks`\n\n\n该测试包提供了renderHook和act等方法，能够更加语义化地去创建自定义Hooks的单元测试。\n\n\n# 常用的第三方工具库\n\n\n## lodash\n\n\n它提供了非常多的工具函数，可以大大提高开发效率。\n\n\n### 使用keyBy将数组快速转换成对象\n\n\n```typescript\nconst data = [\n\t{\n\t\tid: 1,\n\t\tname: \"Ken\",\n\t\tcity: \"Hangzhou\"\n\t},\n\t{\n\t\tid: 2,\n\t\tname: \"Kenny\",\n\t\tcity: \"Guangzhou\"\n\t}\n]\n```\n\n\n```typescript\n// 将其变成一个以name为key的map结构\nimport _ from 'lodash'\nconst byName = _.keyBy(data. 'name')\n```\n\n\n### 使用debounce函数，实现输入防抖\n\n\n可以实现只有在用户停止输入后一个很短的时间内才进行change操作，以保证更好的用户体验。\n\n\n```typescript\n<input onChange={_.dobounce(e => setSearch(e.target.value), 300)} />\n```\n\n\n### 使用template实现简单的模版引擎\n\n\n可以方便地实现一些复杂的字符串生成。\n\n\n可以参考相关的[官方文档](https://www.lodashjs.com/)。\n\n\n## UI库：Ant Design和Material UI\n\n- Material UI：采用了Google的Material Design的设计语言，但是它的**组件库缺少一些高级的功能**。\n- Ant Design：主打企业级应用的场景，提供了各种高级组件，可以满足企业级的复杂交互应用场景。\n\n## react-use\n\n\n### useSearchParams\n\n\n获取URL中的查询字符串。\n\n\n### useEvent\n\n\n如果用DOM的原生API去绑定事件，通常需要在组件创建时去监听，再在销毁时取消监听。useEvent封装了这个逻辑：\n\n\n```typescript\nuseEvent('hashchange', onHashChange)\n```\n\n\n### useCookie\n\n\n它可以方便地去读取，更新或者删除某个Cookie。\n\n\n### usePrevious\n\n\n获取某个state的上一个值。\n\n"
  }
]