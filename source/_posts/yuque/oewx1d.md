---
title: 「Daily」interview list 2
urlname: oewx1d
date: '2021-06-29 10:32:37 +0800'
tags:
  - Daily
categories:
  - Daily
---

> 目录请查看大纲。

#### 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？

JS 采用 IEEE 754 双精度版本（64 位），并且只要采用 IEEE 754 的语言都有该问题。
计算机是通过二进制来存储东西的，那么 `0.1`  在二进制中会表示为：

```javascript
// (0011) 表示循环
0.1 = 2 ^ (-4 * 1.10011(0011));
```

`0.1` 在二进制中是无限循环的一些数字，很多十进制小数用二进制表示都是无限循环的。
但是 JS 采用的浮点数标准却会裁剪掉这些循环数字。
IEEE 754 双精度版本（64 位）将 64 位分为了三段：

- 第一位用来表示符号
- 接下去的 11 位用来表示指数
- 其他的位数用来表示有效位，也就是用二进制表示 0.1 中的 10011(0011)

于是出现精度丢失的问题，也就造成了  `0.1`不再是  `0.1`  了，而是变成了  `0.100000000000000002`
根据双精度浮点数的定义，非整数 Number 无法使用==/===进行比较，正确的比较方法是使用 JS 提供的最小精度值：

```javascript
Math.abs(0.1 + 0.2 - 0.3) <= Number.EPSILON;
```

#### 什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？

[>浏览器如何工作](https://www.yuque.com/httishere/running/rpkxit)
首先需要了解**浏览器渲染原理。**
执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。

- **浏览器接收到 HTML 文件并转换为 DOM 树**

当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。
当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。
![](https://cdn.nlark.com/yuque/0/2021/png/250093/1624938436668-382eb8b8-055d-4baa-89a3-07daef6e9004.png#align=left&display=inline&height=214&margin=%5Bobject%20Object%5D&name=&originHeight=214&originWidth=519&size=0&status=done&style=none&width=519)
当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。
![](https://cdn.nlark.com/yuque/0/2021/png/250093/1624938512749-af1bcf95-18eb-47a6-98b4-a926add1d504.png#align=left&display=inline&height=274&margin=%5Bobject%20Object%5D&name=&originHeight=274&originWidth=622&size=0&status=done&style=none&width=622)
浏览器从网络中接收到 HTML 文件然后一系列的转换过程:
**字节数据 => 字符串 => Token => Node => Dom**

- **将 CSS 文件转换为 CSSOM 树**

也是于 HTML 的转换是类似的。

> 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式是可以自行设置的，也可以通过继承获得。在这一过程中，浏览器得**递归 CSSOM 树**，然后确定具体的元素到底是什么样式。

- **生成渲染树**

生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。
![](https://cdn.nlark.com/yuque/0/2021/png/250093/1624947381540-b36ede66-6f55-481e-9135-69bce1d74f49.png#align=left&display=inline&height=537&margin=%5Bobject%20Object%5D&name=&originHeight=537&originWidth=1150&size=0&status=done&style=none&width=1150)
渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 `display: none`  的，那么就不会在渲染树中显示。
当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。

**JS 操作 DOM**
DOM 是属于渲染引擎中的，而 JS 是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。

**相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM 即 Virtual DOM。**
需要在数据更新时，对比新旧两个 JS 对象然后实现局部更新 DOM。

- 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异（需要判断新旧节点的 `tagName`是否相同，如果不相同的话就代表节点被替换了。如果没有更改 `tagName`的话，就需要判断是否有子元素，有的话就进行第二步算法）；
- 一旦节点有子元素，就去判断子元素是否有不同（需要判断原本的列表中是否有节点被移除，在新的列表中需要判断是否有新的节点加入，还需要判断节点是否有移动）；

所以我们在使用模版的 `v-for`或者 `array.map`时会常常遇到** `key`这个属性**，这个属性是用来给每一个节点打标志的，用于**判断是否是同一个节点**。

1. 将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发。
1. 同样的，通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等等。
1. 实现组件的高度抽象化

#### 前端路由原理？两种实现方式有什么区别？

本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新页面。目前前端使用的路由就只有两种实现方式：

- Hash 模式
- History 模式

##### hash 模式（xxx.com/#/）

当 # 后面的哈希值发生变化时，可以通过 `hashchange`事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 xxx.com。

##### history 模式

History 模式是 HTML5 新推出的功能，主要使用`history.pushState`和`history.replaceState`改变 URL。
通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。

1. Hash 模式只可以更改 `#`后面的内容，History 模式可以通过 API 设置任意的同源 URL；
1. History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串；
1. Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候；

#### 组件内的 data 为何不使用对象，而是函数形式

**组件复用**时所有组件实例都会**共享 data**，如果 data 是对象的话，就会造成一个组件修改 data 以后会影响到其他所有组件，所以需要将 data 写成函数，每次用到就调用一次函数获得新的数据。
当我们使用 new Vue() 的方式的时候，无论我们将 data 设置为对象还是函数都是可以的，因为 new Vue() 的方式是生成一个根组件，该组件不会复用，也就不存在共享 data 的情况了。
